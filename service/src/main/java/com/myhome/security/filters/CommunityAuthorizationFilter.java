package com.myhome.security.filters;

import com.myhome.domain.User;
import com.myhome.services.CommunityService;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * is a custom authentication filter that restricts access to community amenities
 * based on user identity and community administration roles. The filter checks if
 * the user is a community admin by querying the community service, and if not, it
 * sets the status code to FORBIDDEN. If the user is a community admin, the filter
 * allows the request to proceed to the next filter in the chain.
 */
public class CommunityAuthorizationFilter extends BasicAuthenticationFilter {
  private final CommunityService communityService;
  private static final String UUID_PATTERN =
      "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}";
  private static final Pattern ADD_AMENITY_REQUEST_PATTERN =
      Pattern.compile("/communities/" + UUID_PATTERN + "/amenities");

  public CommunityAuthorizationFilter(AuthenticationManager authenticationManager,
      CommunityService communityService) {
    super(authenticationManager);
    this.communityService = communityService;
  }

  /**
   * filters HTTP requests based on a pattern and checks if the user is an admin of a
   * specific community. If not, it responds with a forbidden status code, otherwise,
   * it passes the request to the next filter in the chain.
   * 
   * @param request HTTP request that is being processed by the filter.
   * 
   * 	- `request.getRequestURI()` returns the request URL, which is matched against a
   * pattern to determine if it belongs to an amenity request.
   * 	- `urlMatcher.find()` returns `true` if the pattern matches, and `false` otherwise.
   * 	- `isUserCommunityAdmin(request)` checks whether the current user is an admin for
   * the community, and if not, sets the response status code to `HttpServletResponse.SC_FORBIDDEN`.
   * 	- `super.doFilterInternal(request, response, chain)` calls the parent method to
   * handle the request.
   * 
   * @param response HTTP response object that is being filtered by the current code snippet.
   * 
   * 	- `HttpServletResponse response`: This is an instance of the `HttpServletResponse`
   * class, which contains information about the HTTP request and response headers and
   * status code.
   * 	- `FilterChain chain`: This is a chain of filters that can be used to modify or
   * handle the incoming request.
   * 	- `HttpServletRequest request`: This is an instance of the `HttpServletRequest`
   * class, which contains information about the incoming HTTP request.
   * 
   * @param chain next filter in the chain that should be executed after the current
   * filter is applied to the request.
   * 
   * 	- `HttpServletRequest request`: The current HTTP request being processed by the
   * filter.
   * 	- `HttpServletResponse response`: The current HTTP response being generated by
   * the filter.
   * 	- `FilterChain chain`: An instance of the `FilterChain` interface, which represents
   * a sequence of filters that can be applied to the current request.
   * 
   * The `chain` object has various attributes and methods that can be used to manipulate
   * the flow of the request through the filter chain. For example, the `doFilterInternal`
   * method can call the `doFilter` method of the next filter in the chain, or it can
   * stop the processing of the current request by returning early. The `chain` object
   * also provides a way to access the previous filters in the chain, which can be
   * useful for storing state between filter iterations.
   */
  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
      FilterChain chain) throws IOException, ServletException {

    Matcher urlMatcher = ADD_AMENITY_REQUEST_PATTERN.matcher(request.getRequestURI());

    if (urlMatcher.find() && !isUserCommunityAdmin(request)) {
      response.setStatus(HttpServletResponse.SC_FORBIDDEN);
      return;
    }

    super.doFilterInternal(request, response, chain);
  }

  /**
   * determines if a user is an admin of a community by querying the community service
   * and checking if the user's ID exists in the list of admins for that community.
   * 
   * @param request HTTP request object containing information about the current user
   * and their session, which is used to determine if the user is a community admin.
   * 
   * 	- `request.getRequestURI()`: This method returns the request URI, which is the
   * path portion of the HTTP request. In this case, it splits into two parts: the
   * scheme and the authority.
   * 	- `(String) SecurityContextHolder.getContext().getAuthentication().getPrincipal()`:
   * This line retrieves the currently authenticated user ID from the SecurityContextHolder,
   * which stores the security context for the current thread. The `getPrincipal()`
   * method of the Authentication object returns the user principal, which represents
   * the user who is being authenticated.
   * 	- `request.getParameter(â€œuserId")`: This line retrieves a parameter from the HTTP
   * request called "userId".
   * 	- `communityId = request.getRequestURI().split("/")[2]`: This line splits the
   * request URI into its scheme and authority components, and extracts the second
   * component (the authority) as the community ID.
   * 
   * @returns a boolean value indicating whether the current user is an admin of a
   * specific community.
   * 
   * 	- `SecurityContextHolder`: This is an instance of `SecurityContextHolder`, which
   * is used to store and retrieve authentication information in a Spring Security context.
   * 	- `getContext()`: This method returns the current security context, which contains
   * information about the currently authenticated user and any other security-related
   * contextual information.
   * 	- `getAuthentication()`: This method returns the current authentication object,
   * which represents the authenticated user.
   * 	- `getPrincipal()`: This method returns the principal object associated with the
   * authentication object, which represents the user who is being authenticated.
   * 	- `communityService`: This is an instance of `CommunityService`, which is used
   * to interact with the community service layer.
   * 	- `findCommunityAdminsById()`: This method finds a list of community admins for
   * a given community ID using the community service layer.
   * 	- `flatMap()`: This method flattens the list of community admins into a stream,
   * which allows for more efficient processing.
   * 	- `map()`: This method maps each admin in the list to their user ID, which is
   * used as a filter condition.
   * 	- `filter()`: This method filters the list of user IDs to find the ID of the
   * currently authenticated user.
   * 	- `findFirst()`: This method finds the first element that matches the filter
   * condition (in this case, the ID of the currently authenticated user), or returns
   * `Optional.empty()` if no such element is found.
   * 	- `isPresent()`: This method checks whether the result returned by `findFirst()`
   * is present, which indicates whether the currently authenticated user is a community
   * admin for the given community.
   */
  private boolean isUserCommunityAdmin(HttpServletRequest request) {
    String userId = (String) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    String communityId = request.getRequestURI().split("/")[2];

    return communityService.findCommunityAdminsById(communityId, null)
        .flatMap(admins -> admins.stream()
            .map(User::getUserId)
            .filter(userId::equals)
            .findFirst()
        )
        .isPresent();
  }
}
