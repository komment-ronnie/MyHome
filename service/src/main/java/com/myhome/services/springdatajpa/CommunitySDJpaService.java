/*
 * Copyright 2020 Prathab Murugan
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.myhome.services.springdatajpa;

import com.myhome.controllers.dto.CommunityDto;
import com.myhome.controllers.dto.mapper.CommunityMapper;
import com.myhome.domain.Community;
import com.myhome.domain.CommunityHouse;
import com.myhome.domain.HouseMember;
import com.myhome.domain.User;
import com.myhome.repositories.CommunityHouseRepository;
import com.myhome.repositories.CommunityRepository;
import com.myhome.repositories.UserRepository;
import com.myhome.services.CommunityService;
import com.myhome.services.HouseService;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;
import javax.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Pageable;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

/**
 * is an implementation of the Service interface in Spring Boot that provides methods
 * for managing communities and their houses through JPA (Java Persistence API). The
 * class handles removing a house from a community by first removing the house from
 * the community's houses list, then deleting the house members associated with the
 * house, and finally saving the community and deleting the house. The method uses
 * the `UUID` class to generate a unique identifier for the house to be removed, and
 * then removes the house from the community's houses list using JPA. It also removes
 * the house members associated with the house using the `HouseService` interface,
 * and then saves the community using JPA and deletes the house using the `CommunityHouseRepository`.
 */
@Slf4j
@RequiredArgsConstructor
@Service
public class CommunitySDJpaService implements CommunityService {
  private final CommunityRepository communityRepository;
  private final UserRepository communityAdminRepository;
  private final CommunityMapper communityMapper;
  private final CommunityHouseRepository communityHouseRepository;
  private final HouseService houseService;

  /**
   * generates a unique ID for a community, adds an administrator with the provided
   * user ID to the community, saves the community to the repository, and logs the save
   * event.
   * 
   * @param communityDto CommunityDto object that contains the details of the community
   * to be created, which is then transformed into a Community entity by the `communityMapper`
   * and added to the repository for storage.
   * 
   * 	- `communityDto.setCommunityId(generateUniqueId());`: The `communityDto` object's
   * `CommunityId` field is set to a randomly generated unique identifier using the
   * `generateUniqueId()` method.
   * 	- `String userId = (String) SecurityContextHolder.getContext().getAuthentication().getPrincipal();`:
   * The `userId` variable is assigned the value of the authenticated user's principal
   * (i.e., username) obtained from the current security context.
   * 	- `Community community = addAdminToCommunity(communityMapper.communityDtoToCommunity(communityDto),
   * userId);`: The `addAdminToCommunity()` method takes the deserialized `communityDto`
   * object and adds an administrator to the community using the `communityMapper`
   * method to map the `CommunityDto` object to a `Community` object.
   * 	- `Community savedCommunity = communityRepository.save(community);`: The
   * `savedCommunity` variable is assigned the result of saving the `Community` object
   * retrieved from the `communityRepository` using the `save()` method.
   * 
   * @returns a `Community` object that has been saved to the repository with a unique
   * ID.
   * 
   * 	- `community`: The community object saved in the repository with a unique ID
   * generated by the function.
   * 	- `userId`: The user ID of the authenticated principal, which is used to add an
   * admin to the community.
   * 	- `communityMapper`: A mapper object used to map the `CommunityDto` object to a
   * `Community` object for persistence in the repository.
   * 	- `securityContextHolder`: A holder for the security context, which provides
   * access to the authenticated principal's details.
   * 	- `log`: A logging tool used to log trace messages related to the function's execution.
   */
  @Override
  public Community createCommunity(CommunityDto communityDto) {
    communityDto.setCommunityId(generateUniqueId());
    String userId = (String) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    Community community = addAdminToCommunity(communityMapper.communityDtoToCommunity(communityDto),
        userId);
    Community savedCommunity = communityRepository.save(community);
    log.trace("saved community with id[{}] to repository", savedCommunity.getId());
    return savedCommunity;
  }

  /**
   * adds a user as an administrator to a Community by retrieving the user's existing
   * administrative roles, adding the Community to those roles, and storing the updated
   * list of admins for the Community.
   * 
   * @param community Community object that the function modifies by adding an admin
   * to its list of admins.
   * 
   * 	- `community`: A `Community` object representing the community to which an admin
   * is being added.
   * 	- `userId`: A `String` representing the user ID of the admin to be added.
   * 	- `admin`: An `Admin` object representing the admin to be added to the community.
   * 	- `communities`: A `Set<Community>` representing the communities that the admin
   * belongs to.
   * 	- `setAdmins`: A `Set<User>` representing the set of admins for the community.
   * 
   * @param userId ID of the user whose communities are being added to the specified `Community`.
   * 
   * @returns a modified Community object with the added admin and their associated communities.
   * 
   * 	- The `community` object is updated by adding the specified user's admin to the
   * community's list of admins.
   * 	- The `admins` field of the `community` object is replaced with a new `Set`
   * containing the updated admin.
   * 
   * The function does not modify any other attributes or properties of the input
   * parameters or the output `community` object.
   */
  private Community addAdminToCommunity(Community community, String userId) {
    communityAdminRepository.findByUserIdWithCommunities(userId).ifPresent(admin -> {
      admin.getCommunities().add(community);
      Set<User> admins = new HashSet<>();
      admins.add(admin);
      community.setAdmins(admins);
    });
    return community;
  }

  /**
   * returns a set of all communities stored in the repository, obtained by iterating
   * over the result of a call to `findAll` with the given pageable parameter.
   * 
   * @param pageable pagination information for retrieving the communities, allowing
   * the function to iterate over them and add them to the `communityListSet`.
   * 
   * 	- `Pageable`: This is a generic interface that defines a pageable view model,
   * which can be used to navigate through a sequence of objects. It has various
   * attributes and methods, such as `getNumberOfElements`, `getPagePosition`,
   * `getPageSize`, and `nextPage`.
   * 
   * @returns a set of `Community` objects.
   * 
   * 	- `Set<Community> communityListSet`: This is a set of all communities returned
   * by the function. It contains multiple community objects, each representing a
   * community in the database.
   * 	- `communityRepository`: This is the repository class that performs CRUD operations
   * on the community table. The `findAll` method is used to retrieve a list of all
   * communities from the database.
   * 	- `pageable`: This is an object of the `Pageable` interface, which provides a way
   * to page through the results of a query. It can be used to specify the starting
   * point and number of results to return in the list.
   */
  @Override
  public Set<Community> listAll(Pageable pageable) {
    Set<Community> communityListSet = new HashSet<>();
    communityRepository.findAll(pageable).forEach(communityListSet::add);
    return communityListSet;
  }

  /**
   * retrieves a set of `Community` objects from the database using the
   * `communityRepository.findAll()` method and stores them in a new `HashSet`.
   * 
   * @returns a set of `Community` objects representing all existing communities.
   * 
   * 	- The output is a `Set` of `Community` objects, indicating that it contains
   * multiple communities.
   * 	- The `Set` is created using the `new HashSet` method, which means that the
   * elements are stored in a hash table for efficient lookups.
   * 	- The function populates the `Set` with the results of calling the `findAll`
   * method on the `communityRepository`. This ensures that the output contains all the
   * communities available in the repository.
   * 
   * The output of the `listAll` function has no additional attributes or properties
   * beyond its type and contents.
   */
  @Override public Set<Community> listAll() {
    Set<Community> communities = new HashSet<>();
    communityRepository.findAll().forEach(communities::add);
    return communities;
  }

  /**
   * retrieves a list of `CommunityHouse` instances based on a given `communityId`. It
   * first checks if the community exists in the repository, and then retrieves the
   * list of `CommunityHouse` instances associated with that community using the `communityHouseRepository`.
   * 
   * @param communityId unique identifier for a community and is used to filter the
   * results of the query to only include houses associated with that community.
   * 
   * @param pageable pagination information for fetching a subset of community houses
   * based on the `communityId`.
   * 
   * 	- The `Pageable` interface has two methods: `getPageNumber()` and `getPageSize()`.
   * 	- The `getPageNumber()` method returns the current page number.
   * 	- The `getPageSize()` method returns the number of elements per page.
   * 
   * @returns a `Optional<List<CommunityHouse>>`, which contains a list of community
   * houses if the community exists, otherwise it returns an empty list.
   * 
   * 1/ `Optional<List<CommunityHouse>>`: This indicates that the function returns an
   * optional list of community houses, which means it can be either empty or contain
   * a list of community houses.
   * 2/ `findAllByCommunity_CommunityId(communityId, pageable)`: This is a method call
   * from the `communityHouseRepository` class, which retrieves all community houses
   * that belong to the specified community ID using the `pageable` parameter for paging.
   * 3/ `existsByCommunityId(communityId)`: This is a boolean method call from the
   * `communityRepository` class, which checks if there are any community houses
   * associated with the given community ID. If no community houses exist, this method
   * returns `true`.
   */
  @Override
  public Optional<List<CommunityHouse>> findCommunityHousesById(String communityId,
      Pageable pageable) {
    boolean exists = communityRepository.existsByCommunityId(communityId);
    if (exists) {
      return Optional.of(
          communityHouseRepository.findAllByCommunity_CommunityId(communityId, pageable));
    }
    return Optional.empty();
  }

  /**
   * retrieves a list of community admins for a given community ID using two queries:
   * one to check if the community exists, and another to retrieve the list of admins.
   * If the community exists, the function returns an Optional containing the list of
   * admins; otherwise, it returns an emptyOptional.
   * 
   * @param communityId ID of the community for which the list of community admins is
   * to be retrieved.
   * 
   * @param pageable page of results to be returned by the query, allowing for pagination
   * and control over the size of the result set.
   * 
   * 	- `communityId`: The id of the community for which admins need to be fetched.
   * 	- `pageable`: A `Pageable` object representing the pagination requirements for
   * the query. It typically contains the page number, page size, sort order, and other
   * parameters used to filter and display a subset of data within a larger dataset.
   * 
   * @returns an optional list of `User` objects associated with a given community ID.
   * 
   * 	- The function returns an `Optional` object containing a list of `User` objects
   * if there are any community admins associated with the given community ID.
   * 	- If no community admins exist for the provided community ID, the `Optional`
   * object is empty.
   * 	- The list of `User` objects contained in the `Optional` object is retrieved from
   * the `communityAdminRepository` by calling the `findAllByCommunities_CommunityId`
   * method and passing the community ID as a parameter.
   */
  @Override
  public Optional<List<User>> findCommunityAdminsById(String communityId,
      Pageable pageable) {
    boolean exists = communityRepository.existsByCommunityId(communityId);
    if (exists) {
      return Optional.of(
          communityAdminRepository.findAllByCommunities_CommunityId(communityId, pageable)
      );
    }
    return Optional.empty();
  }

  /**
   * queries the `communityAdminRepository` for a `User` entity by its `adminId`. It
   * returns an optional instance of `User` if found, or `Optional.empty()` otherwise.
   * 
   * @param adminId ID of a user to find the corresponding community administrator in
   * the `communityAdminRepository`.
   * 
   * @returns an optional instance of `User`.
   * 
   * 	- `Optional<User>`: This represents an optional user object, indicating that the
   * function may return null if no community admin is found for the given ID.
   * 	- `findByUserId(adminId)`: This method call returns a User object representing
   * the community admin associated with the given ID.
   */
  @Override
  public Optional<User> findCommunityAdminById(String adminId) {
    return communityAdminRepository.findByUserId(adminId);
  }

  /**
   * retrieves community details by Id from the repository.
   * 
   * @param communityId unique identifier of a community for which details are sought
   * by the caller.
   * 
   * @returns an optional instance of `Community`.
   * 
   * 	- `Optional<Community>`: This represents an optional Community object, which means
   * that if no Community record is found with the provided communityId, the function
   * will return an empty Optional.
   * 	- `Community`: This class represents a Community object, containing fields such
   * as `id`, `name`, `description`, and `location`.
   */
  @Override public Optional<Community> getCommunityDetailsById(String communityId) {
    return communityRepository.findByCommunityId(communityId);
  }

  /**
   * retrieves community details and administrator information for a specified community
   * ID from the repository.
   * 
   * @param communityId ID of the Community object that the function is intended to
   * retrieve details for.
   * 
   * @returns an Optional object containing the details of the community with associated
   * admins.
   * 
   * 	- `Optional<Community>`: The function returns an optional object containing a
   * Community instance if one is found, or an empty Optional if no match is found.
   * 	- `communityRepository`: This is the repository class used to fetch the Community
   * instances from the database.
   * 	- `findByCommunityIdWithAdmins(communityId)`: This method retrieves Community
   * instances from the database based on the provided community ID and includes the
   * admins of the Community in the results.
   */
  @Override
  public Optional<Community> getCommunityDetailsByIdWithAdmins(String communityId) {
    return communityRepository.findByCommunityIdWithAdmins(communityId);
  }

  /**
   * searches for a community with the given `communityId`, retrieves its admins from
   * the repository, and adds the provided admins to the community's admin list. It
   * then saves the updated community.
   * 
   * @param communityId ID of the community to add admins to.
   * 
   * @param adminsIds Set of user IDs of the admins to add to the community.
   * 
   * 	- `Set<String> adminsIds`: This represents a set of strings that contains the IDs
   * of the admins to be added to the community.
   * 	- `adminsIds`: A collection of ID strings that represent the identifiers of the
   * admins to be added to the community.
   * 
   * @returns an `Optional` containing a modified `Community` object with additional
   * `Admin` objects added as admins.
   * 
   * 	- `Optional<Community> communitySearch`: This is an optional `Community` object
   * that represents the found community with admins or an empty result if no matching
   * community was found.
   * 	- `map(function)`: This method maps the `community` object to a new `Community`
   * object by adding the provided `adminsIds` to the community's admin set and saving
   * the updated community in the repository. The returned value is an `Optional<Community>`
   * object containing the saved community.
   * 	- `orElseGet(function)`: This method returns an `Optional<Community>` object
   * containing the saved community if the `communitySearch` is empty, or an empty
   * `Optional` object otherwise.
   * 
   * In summary, the `addAdminsToCommunity` function takes a `communityId` and a
   * `Set<String>` of admin IDs as input, finds the community with the matching ID in
   * the repository, adds the provided admins to the community's admin set, and saves
   * the updated community in the repository. The output is an `Optional<Community>`
   * object containing the saved community.
   */
  @Override
  public Optional<Community> addAdminsToCommunity(String communityId, Set<String> adminsIds) {
    Optional<Community> communitySearch =
        communityRepository.findByCommunityIdWithAdmins(communityId);

    return communitySearch.map(community -> {
      adminsIds.forEach(adminId -> {
        communityAdminRepository.findByUserIdWithCommunities(adminId).map(admin -> {
          admin.getCommunities().add(community);
          community.getAdmins().add(communityAdminRepository.save(admin));
          return admin;
        });
      });
      return Optional.of(communityRepository.save(community));
    }).orElseGet(Optional::empty);
  }

  /**
   * adds new or updated houses to a community by identifying existing houses, updating
   * their IDs, and adding them to the community's list of houses. It also saves the
   * community and its updated house list.
   * 
   * @param communityId ID of the community to which the houses will be added or updated.
   * 
   * @param houses set of houses to be added to the community, and the function adds
   * each house to the community if it is not already present in the community's houses
   * list.
   * 
   * 	- `houses`: A set of `CommunityHouse` objects that represent houses in a community.
   * Each house has an `id`, `name`, and `communtiy` field.
   * 	- `id`: A unique identifier for each house, generated by the function for each
   * new house added to the community.
   * 	- `name`: The name of each house.
   * 	- `communtiy`: The community to which each house belongs.
   * 
   * @returns a set of unique house IDs that have been added to the specified community.
   * 
   * 	- `Set<String> addedIds`: This represents the set of house IDs that were successfully
   * added to the community. These IDs are unique and have not been previously used in
   * the community.
   * 	- `Optional<Community> communitySearch`: This is an optional object representing
   * the community that was found in the repository with the given `communityId`. If
   * no community is found, this object will be `None`.
   * 	- `Set<CommunityHouse> houses`: This set represents the collection of houses
   * passed as a parameter to the function. Each house has its own `houseId`, `name`,
   * and `communities` list, which may change after the function execution.
   * 
   * The function first searches for an existing community with the given `communityId`
   * in the repository using the `findByCommunityIdWithHouses` method. If no community
   * is found, the function returns an empty set of added IDs. Otherwise, it iterates
   * over the houses collection and checks if each house already exists in the community
   * by comparing its `houseId`, `name`, and `communities` list with those of the
   * existing houses in the community. If a house does not exist, it is created with a
   * unique ID generated using `generateUniqueId()`, and added to the community's
   * `houses` list. The new house's `houseId` and `name` are also updated. Finally, the
   * community is saved using the `save` method, and the set of added IDs is returned.
   */
  @Override
  public Set<String> addHousesToCommunity(String communityId, Set<CommunityHouse> houses) {
    Optional<Community> communitySearch =
        communityRepository.findByCommunityIdWithHouses(communityId);

    return communitySearch.map(community -> {
      Set<String> addedIds = new HashSet<>();

      houses.forEach(house -> {
        if (house != null) {
          boolean houseExists = community.getHouses().stream()
              .noneMatch(communityHouse ->
                  communityHouse.getHouseId().equals(house.getHouseId())
                      && communityHouse.getName().equals(house.getName())
              );
          if (houseExists) {
            house.setHouseId(generateUniqueId());
            house.setCommunity(community);
            addedIds.add(house.getHouseId());
            communityHouseRepository.save(house);
            community.getHouses().add(house);
          }
        }
      });

      communityRepository.save(community);

      return addedIds;
    }).orElse(new HashSet<>());
  }

  /**
   * removes an admin from a community by searching for the community and removing the
   * admin if found, then saving the updated community.
   * 
   * @param communityId ID of the community to remove an admin from.
   * 
   * @param adminId ID of an admin to be removed from a community.
   * 
   * @returns a boolean value indicating whether an admin was successfully removed from
   * a community.
   */
  @Override
  public boolean removeAdminFromCommunity(String communityId, String adminId) {
    Optional<Community> communitySearch =
        communityRepository.findByCommunityIdWithAdmins(communityId);
    return communitySearch.map(community -> {
      boolean adminRemoved =
          community.getAdmins().removeIf(admin -> admin.getUserId().equals(adminId));
      if (adminRemoved) {
        communityRepository.save(community);
        return true;
      } else {
        return false;
      }
    }).orElse(false);
  }

  /**
   * deletes a community from the repository by finding all the houses associated with
   * it, removing them one by one, and then deleting the community itself.
   * 
   * @param communityId ID of the community to be deleted, which is used to locate and
   * delete the corresponding community record in the repository.
   * 
   * @returns a boolean value indicating whether the community was successfully deleted.
   */
  @Override
  @Transactional
  public boolean deleteCommunity(String communityId) {
    return communityRepository.findByCommunityIdWithHouses(communityId)
        .map(community -> {
          Set<String> houseIds = community.getHouses()
              .stream()
              .map(CommunityHouse::getHouseId)
              .collect(Collectors.toSet());

          houseIds.forEach(houseId -> removeHouseFromCommunityByHouseId(community, houseId));
          communityRepository.delete(community);

          return true;
        })
        .orElse(false);
  }

  /**
   * generates a unique identifier using the `UUID.randomUUID()` method and returns it
   * as a string.
   * 
   * @returns a unique string of 36 characters, generated using the UUID random number
   * generator.
   */
  private String generateUniqueId() {
    return UUID.randomUUID().toString();
  }

  /**
   * removes a house from a community by first removing the house members associated
   * with the house, then deleting the house itself, and finally saving the updated
   * community and deleting the house's record in the database.
   * 
   * @param community Community object that is being updated or deleted, and it is used
   * to retrieve the Set of House objects associated with the Community and to save the
   * updated Community object after removing the house.
   * 
   * 	- `community`: A `Community` object representing the community to remove the house
   * from.
   * 	- `houseId`: The unique identifier of the house to be removed from the community.
   * 
   * @param houseId ID of the house to be removed from the community.
   * 
   * @returns a boolean value indicating whether the house was successfully removed
   * from the community.
   */
  @Transactional
  @Override
  public boolean removeHouseFromCommunityByHouseId(Community community, String houseId) {
    if (community == null) {
      return false;
    } else {
      Optional<CommunityHouse> houseOptional =
          communityHouseRepository.findByHouseIdWithHouseMembers(houseId);
      return houseOptional.map(house -> {
        Set<CommunityHouse> houses = community.getHouses();
        houses.remove(
            house); //remove the house before deleting house members because otherwise the Set relationship would be broken and remove would not work

        Set<String> memberIds = house.getHouseMembers()
            .stream()
            .map(HouseMember::getMemberId)
            .collect(
                Collectors.toSet()); //streams are immutable so need to collect all the member IDs and then delete them from the house

        memberIds.forEach(id -> houseService.deleteMemberFromHouse(houseId, id));

        communityRepository.save(community);
        communityHouseRepository.deleteByHouseId(houseId);
        return true;
      }).orElse(false);
    }
  }
}
