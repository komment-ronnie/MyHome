package com.myhome.services.springdatajpa;

import com.myhome.controllers.dto.UserDto;
import com.myhome.controllers.exceptions.CredentialsIncorrectException;
import com.myhome.controllers.exceptions.UserNotFoundException;
import com.myhome.domain.AuthenticationData;
import com.myhome.model.LoginRequest;
import com.myhome.security.jwt.AppJwt;
import com.myhome.security.jwt.AppJwtEncoderDecoder;
import com.myhome.services.AuthenticationService;
import java.time.Duration;
import java.time.LocalDateTime;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

/**
 * is responsible for authenticating users by checking their password against an
 * encrypted version stored in the database. It generates a JWT token containing the
 * user ID and other relevant information using the deserialized user data, and encodes
 * it with a secret key for added security. The class also includes methods for
 * comparing passwords and creating new AppJwt instances.
 */
@Slf4j
@Service
public class AuthenticationSDJpaService implements AuthenticationService {

  private final Duration tokenExpirationTime;
  private final String tokenSecret;

  private final UserSDJpaService userSDJpaService;
  private final AppJwtEncoderDecoder appJwtEncoderDecoder;
  private final PasswordEncoder passwordEncoder;

  public AuthenticationSDJpaService(@Value("${token.expiration_time}") Duration tokenExpirationTime,
      @Value("${token.secret}") String tokenSecret,
      UserSDJpaService userSDJpaService,
      AppJwtEncoderDecoder appJwtEncoderDecoder,
      PasswordEncoder passwordEncoder) {
    this.tokenExpirationTime = tokenExpirationTime;
    this.tokenSecret = tokenSecret;
    this.userSDJpaService = userSDJpaService;
    this.appJwtEncoderDecoder = appJwtEncoderDecoder;
    this.passwordEncoder = passwordEncoder;
  }

  /**
   * authenticates a user by checking their password and creating an encoded JWT token.
   * If the password is incorrect, it throws an exception with the user ID. Otherwise,
   * it returns an AuthenticationData object containing the encoded token and user ID.
   * 
   * @param loginRequest login request received by the authentication service and
   * contains information such as the email address of the user attempting to log in.
   * 
   * 	- `loginRequest.getEmail()` returns the email address of the user making the login
   * request.
   * 	- `loginRequest.getPassword()` returns the password provided by the user for
   * authentication verification.
   * 	- `userSDJpaService.findUserByEmail(loginRequest.getEmail())` retrieves the user
   * record from the database based on the provided email address.
   * 	- `orElseThrow(() -> new UserNotFoundException(loginRequest.getEmail()))` handles
   * the case where the user with the provided email address is not found in the database,
   * throwing an exception with the email address as the message.
   * 	- `isPasswordMatching(loginRequest.getPassword(), userDto.getEncryptedPassword())`
   * compares the provided password with the encrypted password stored for the user,
   * and throws an exception if they do not match.
   * 	- `createJwt(userDto)` generates a JWT token using the user details, which will
   * be encoded later.
   * 	- `appJwtEncoderDecoder.encode(jwtToken, tokenSecret)` encodes the JWT token with
   * the secret key, resulting in an encoded token.
   * 
   * @returns an `AuthenticationData` object containing the encoded JWT token and the
   * user ID.
   * 
   * 	- The AuthenticationData object contains an encoded token (encodedToken) and the
   * user ID (userId) of the successfully logged-in user.
   * 	- The encoded token is generated by the `createJwt` method using the user's details
   * and a secret token.
   * 	- The `log.trace("Received login request")` statement indicates that the function
   * has been triggered, and the login request is being processed.
   * 	- The `orElseThrow(() -> new UserNotFoundException(loginRequest.getEmail())]`
   * statement checks if a user with the provided email address exists in the database.
   * If no such user exists, a `UserNotFoundException` is thrown.
   */
  @Override
  public AuthenticationData login(LoginRequest loginRequest) {
    log.trace("Received login request");
    final UserDto userDto = userSDJpaService.findUserByEmail(loginRequest.getEmail())
        .orElseThrow(() -> new UserNotFoundException(loginRequest.getEmail()));
    if (!isPasswordMatching(loginRequest.getPassword(), userDto.getEncryptedPassword())) {
      throw new CredentialsIncorrectException(userDto.getUserId());
    }
    final AppJwt jwtToken = createJwt(userDto);
    final String encodedToken = appJwtEncoderDecoder.encode(jwtToken, tokenSecret);
    return new AuthenticationData(encodedToken, userDto.getUserId());
  }

  /**
   * compares a provided `requestPassword` with a reference `databasePassword`, returning
   * `true` if they match and `false` otherwise.
   * 
   * @param requestPassword password entered by the user for authentication purposes.
   * 
   * @param databasePassword password stored in the database that is being compared to
   * the `requestPassword`.
   * 
   * @returns a boolean value indicating whether the provided request password matches
   * the corresponding database password.
   */
  private boolean isPasswordMatching(String requestPassword, String databasePassword) {
    return passwordEncoder.matches(requestPassword, databasePassword);
  }

  /**
   * creates a JWT token based on user information and expiration time, building the
   * token with the user ID, expiration date, and other relevant details.
   * 
   * @param userDto user details for creating the JWT token.
   * 
   * 	- `userId`: The user ID of the JWT token's owner, which is set to `userDto.getUserId()`.
   * 	- `expiration`: The expiration time of the JWT token, calculated by adding the
   * `tokenExpirationTime` to the current LocalDateTime.
   * 
   * @returns a `AppJwt` object containing the user ID and expiration time.
   * 
   * 1/ `userId`: The user ID associated with the JWT.
   * 2/ `expiration`: The expiration time of the JWT, calculated as the current date
   * and time plus the specified token expiration time.
   */
  private AppJwt createJwt(UserDto userDto) {
    final LocalDateTime expirationTime = LocalDateTime.now().plus(tokenExpirationTime);
    return AppJwt.builder()
        .userId(userDto.getUserId())
        .expiration(expirationTime)
        .build();
  }
}
