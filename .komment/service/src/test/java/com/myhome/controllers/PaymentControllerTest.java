{"name":"PaymentControllerTest.java","path":"service/src/test/java/com/myhome/controllers/PaymentControllerTest.java","content":{"structured":{"description":"An endpoint for retrieving all scheduled payments made by administrators in a given community. It uses Spring WebFlux and dependencies on packages such as Spring Web, Spring Data JPA, and Payment API Mapper. The code sets up test data, creates mock implementations of the Community and Payment services, and verifies the interactions between these services and the controller method using verify() statements. The method itself retrieves payments from the Payment service by calling its schedulePayment() method and then maps them to a Rest API response using the Payment API Mapper.","items":[{"id":"1f1221b9-649b-bfbc-2d44-6780dbc49388","ancestors":[],"type":"function","description":"tests the listAllAdminScheduledPayments method of the PaymentController class. The test cases cover various scenarios such as successful retrieval of payments for an admin, retrieval of payments for an admin who is not in the community, and thrown exceptions when the community does not exist. The test classes use PowerMockito to stub and verify interactions with other services and methods.","name":"PaymentControllerTest","code":"class PaymentControllerTest {\n\n  private static final String TEST_TYPE = \"WATER BILL\";\n  private static final String TEST_DESCRIPTION = \"This is your excess water bill\";\n  private static final boolean TEST_RECURRING = false;\n  private static final BigDecimal TEST_CHARGE = BigDecimal.valueOf(50.00);\n  private static final String TEST_DUE_DATE = \"2020-08-15\";\n  private static final String TEST_MEMBER_NAME = \"Test Name\";\n  private static final String TEST_COMMUNITY_NAME = \"Test Community\";\n  private static final String TEST_COMMUNITY_DISTRICT = \"Wonderland\";\n  private static final String TEST_ADMIN_ID = \"1\";\n  private static final String TEST_ADMIN_NAME = \"test_admin_name\";\n  private static final String TEST_ADMIN_EMAIL = \"test_admin_email@myhome.com\";\n  private static final String TEST_ADMIN_PASSWORD = \"password\";\n  private static final String COMMUNITY_ADMIN_NAME = \"Test Name\";\n  private static final String COMMUNITY_ADMIN_EMAIL = \"testadmin@myhome.com\";\n  private static final String COMMUNITY_ADMIN_PASSWORD = \"testpassword@myhome.com\";\n  private static final String COMMUNITY_HOUSE_NAME = \"Test House\";\n  private static final String COMMUNITY_HOUSE_ID = \"5\";\n  private static final String TEST_MEMBER_ID = \"2\";\n  private static final String TEST_ID = \"3\";\n  private static final String TEST_COMMUNITY_ID = \"4\";\n\n  private static final Pageable TEST_PAGEABLE = PageRequest.of(1, 10);\n\n  @Mock\n  private PaymentService paymentService;\n\n  @Mock\n  private SchedulePaymentApiMapper paymentApiMapper;\n\n  @Mock\n  private CommunityService communityService;\n\n  @InjectMocks\n  private PaymentController paymentController;\n\n  @BeforeEach\n  private void init() {\n    MockitoAnnotations.initMocks(this);\n  }\n\n  private PaymentDto createTestPaymentDto() {\n    UserDto userDto = UserDto.builder()\n        .userId(TEST_ADMIN_ID)\n        .communityIds(new HashSet<>(Collections.singletonList(TEST_COMMUNITY_ID)))\n        .id(Long.valueOf(TEST_ADMIN_ID))\n        .encryptedPassword(TEST_ADMIN_PASSWORD)\n        .name(TEST_ADMIN_NAME)\n        .email(TEST_ADMIN_EMAIL)\n        .build();\n    HouseMemberDto houseMemberDto = new HouseMemberDto()\n        .memberId(TEST_MEMBER_ID)\n        .name(TEST_MEMBER_NAME)\n        .id(Long.valueOf(TEST_MEMBER_ID));\n\n    return PaymentDto.builder()\n        .paymentId(TEST_ID)\n        .type(TEST_TYPE)\n        .description(TEST_DESCRIPTION)\n        .charge(TEST_CHARGE)\n        .dueDate(TEST_DUE_DATE)\n        .recurring(TEST_RECURRING)\n        .admin(userDto)\n        .member(houseMemberDto)\n        .build();\n  }\n\n  private CommunityDto createTestCommunityDto() {\n    CommunityDto communityDto = new CommunityDto();\n    communityDto.setName(TEST_COMMUNITY_NAME);\n    communityDto.setDistrict(TEST_COMMUNITY_DISTRICT);\n    communityDto.setCommunityId(TEST_COMMUNITY_ID);\n    return communityDto;\n  }\n\n  private Community getMockCommunity(Set<User> admins) {\n    Community community =\n        new Community(admins, new HashSet<>(), TEST_COMMUNITY_NAME, TEST_COMMUNITY_ID,\n            TEST_COMMUNITY_DISTRICT, new HashSet<>());\n    User admin = new User(COMMUNITY_ADMIN_NAME, TEST_ADMIN_ID, COMMUNITY_ADMIN_EMAIL, false,\n        COMMUNITY_ADMIN_PASSWORD, new HashSet<>(), new HashSet<>());\n    community.getAdmins().add(admin);\n    admin.getCommunities().add(community);\n\n    CommunityHouse communityHouse = getMockCommunityHouse();\n    communityHouse.setCommunity(community);\n    community.getHouses().add(communityHouse);\n\n    return community;\n  }\n\n  private CommunityHouse getMockCommunityHouse() {\n    CommunityHouse communityHouse = new CommunityHouse();\n    communityHouse.setName(COMMUNITY_HOUSE_NAME);\n    communityHouse.setHouseId(COMMUNITY_HOUSE_ID);\n    communityHouse.setHouseMembers(new HashSet<>());\n\n    return communityHouse;\n  }\n\n  private Payment getMockPayment() {\n    User admin =\n        new User(TEST_ADMIN_NAME, TEST_ADMIN_ID, TEST_ADMIN_EMAIL, false, TEST_ADMIN_PASSWORD,\n            new HashSet<>(), new HashSet<>());\n    Community community = getMockCommunity(new HashSet<>());\n    community.getAdmins().add(admin);\n    admin.getCommunities().add(community);\n    return new Payment(TEST_ID, TEST_CHARGE, TEST_TYPE, TEST_DESCRIPTION, TEST_RECURRING,\n        LocalDate.parse(TEST_DUE_DATE, DateTimeFormatter.ofPattern(\"yyyy-MM-dd\")), admin,\n        new HouseMember(TEST_MEMBER_ID, new HouseMemberDocument(), TEST_MEMBER_NAME,\n            new CommunityHouse()));\n  }\n\n  @Test\n  void shouldSchedulePaymentSuccessful() {\n    // given\n    com.myhome.model.SchedulePaymentRequest request =\n        new com.myhome.model.SchedulePaymentRequest()\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n\n    EnrichedSchedulePaymentRequest enrichedRequest =\n        new EnrichedSchedulePaymentRequest(TEST_TYPE, TEST_DESCRIPTION, TEST_RECURRING, TEST_CHARGE,\n            TEST_DUE_DATE, TEST_ADMIN_ID, 1L, TEST_ADMIN_NAME, TEST_ADMIN_EMAIL,\n            TEST_ADMIN_PASSWORD, new HashSet<>(Collections.singletonList(TEST_COMMUNITY_ID)),\n            TEST_MEMBER_ID,\n            2L, \"\", TEST_MEMBER_NAME, COMMUNITY_HOUSE_ID);\n    PaymentDto paymentDto = createTestPaymentDto();\n    com.myhome.model.SchedulePaymentResponse response =\n        new com.myhome.model.SchedulePaymentResponse()\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n\n    Community community = getMockCommunity(new HashSet<>());\n\n    HouseMember member = new HouseMember(TEST_MEMBER_ID, null, TEST_MEMBER_NAME,\n        community.getHouses().iterator().next());\n\n    community.getHouses().iterator().next().getHouseMembers().add(member);\n\n    User admin = community.getAdmins().iterator().next();\n\n    given(paymentApiMapper.enrichSchedulePaymentRequest(request, admin, member))\n        .willReturn(enrichedRequest);\n    given(paymentApiMapper.enrichedSchedulePaymentRequestToPaymentDto(enrichedRequest))\n        .willReturn(paymentDto);\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n    given(paymentApiMapper.paymentToSchedulePaymentResponse(paymentDto))\n        .willReturn(response);\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.of(member));\n    given(communityService.findCommunityAdminById(TEST_ADMIN_ID))\n        .willReturn(Optional.of(community.getAdmins().iterator().next()));\n\n    //when\n    ResponseEntity<com.myhome.model.SchedulePaymentResponse> responseEntity =\n        paymentController.schedulePayment(request);\n\n    //then\n    assertEquals(HttpStatus.CREATED, responseEntity.getStatusCode());\n    assertEquals(response, responseEntity.getBody());\n    verify(paymentApiMapper).enrichSchedulePaymentRequest(request, admin, member);\n    verify(paymentApiMapper).enrichedSchedulePaymentRequestToPaymentDto(enrichedRequest);\n    verify(paymentService).schedulePayment(paymentDto);\n    verify(paymentApiMapper).paymentToSchedulePaymentResponse(paymentDto);\n    verify(paymentService).getHouseMember(TEST_MEMBER_ID);\n  }\n\n  @Test\n  void shouldNotScheduleIfMemberDoesNotExist() {\n    // given\n    com.myhome.model.SchedulePaymentRequest request =\n        new com.myhome.model.SchedulePaymentRequest()\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    PaymentDto paymentDto = createTestPaymentDto();\n    String expectedExceptionMessage = \"House member with given id not exists: \" + TEST_MEMBER_ID;\n\n    given(paymentApiMapper.schedulePaymentRequestToPaymentDto(request))\n        .willReturn(paymentDto);\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.empty());\n\n    // when\n    final RuntimeException runtimeException =\n        assertThrows(RuntimeException.class, () -> paymentController.schedulePayment(request));\n    // then\n    final String exceptionMessage = runtimeException.getMessage();\n    assertEquals(expectedExceptionMessage, exceptionMessage);\n    verifyNoInteractions(paymentApiMapper);\n  }\n\n  @Test\n  void shouldNotScheduleIfAdminDoesntExist() {\n    // given\n    com.myhome.model.SchedulePaymentRequest request =\n        new com.myhome.model.SchedulePaymentRequest()\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    PaymentDto paymentDto = createTestPaymentDto();\n    String expectedExceptionMessage = \"Admin with given id not exists: \" + TEST_ADMIN_ID;\n    com.myhome.model.SchedulePaymentResponse response =\n        new com.myhome.model.SchedulePaymentResponse()\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n\n    HouseMember member = new HouseMember(TEST_MEMBER_ID, null, TEST_MEMBER_NAME, null);\n\n    given(paymentApiMapper.schedulePaymentRequestToPaymentDto(request))\n        .willReturn(paymentDto);\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n    given(paymentApiMapper.paymentToSchedulePaymentResponse(paymentDto))\n        .willReturn(response);\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.of(member));\n    given(communityService.findCommunityAdminById(TEST_ADMIN_ID))\n        .willReturn(Optional.empty());\n\n    // when\n    final RuntimeException runtimeException =\n        assertThrows(RuntimeException.class, () -> paymentController.schedulePayment(request));\n    // then\n    final String exceptionMessage = runtimeException.getMessage();\n    assertEquals(expectedExceptionMessage, exceptionMessage);\n    verifyNoInteractions(paymentApiMapper);\n  }\n\n  @Test\n  void shouldNotScheduleIfAdminIsNotInCommunity() {\n    // given\n    com.myhome.model.SchedulePaymentRequest request =\n        new com.myhome.model.SchedulePaymentRequest()\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    PaymentDto paymentDto = createTestPaymentDto();\n    com.myhome.model.SchedulePaymentResponse response =\n        new com.myhome.model.SchedulePaymentResponse()\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n\n    Community community = getMockCommunity(new HashSet<>());\n    Set<User> admins = community.getAdmins();\n    User admin = admins.iterator().next();\n    admins.remove(admin);\n\n    CommunityHouse communityHouse = community.getHouses().iterator().next();\n\n    HouseMember member = new HouseMember(TEST_MEMBER_ID, null, TEST_MEMBER_NAME, communityHouse);\n\n    given(paymentApiMapper.schedulePaymentRequestToPaymentDto(request))\n        .willReturn(paymentDto);\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n    given(paymentApiMapper.paymentToSchedulePaymentResponse(paymentDto))\n        .willReturn(response);\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.of(member));\n    given(communityService.findCommunityAdminById(TEST_ADMIN_ID))\n        .willReturn(Optional.of(admin));\n\n    //when\n    ResponseEntity<com.myhome.model.SchedulePaymentResponse> responseEntity =\n        paymentController.schedulePayment(request);\n\n    //then\n    assertEquals(HttpStatus.NOT_FOUND, responseEntity.getStatusCode());\n    assertNull(responseEntity.getBody());\n    verify(paymentService).getHouseMember(TEST_MEMBER_ID);\n    verifyNoInteractions(paymentApiMapper);\n    verify(communityService).findCommunityAdminById(TEST_ADMIN_ID);\n  }\n\n  @Test\n  void shouldGetPaymentDetailsSuccess() {\n    // given\n    PaymentDto paymentDto = createTestPaymentDto();\n\n    com.myhome.model.SchedulePaymentResponse expectedResponse =\n        new com.myhome.model.SchedulePaymentResponse()\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    given(paymentService.getPaymentDetails(TEST_ID))\n        .willReturn(Optional.of(paymentDto));\n    given(paymentApiMapper.paymentToSchedulePaymentResponse(paymentDto))\n        .willReturn(expectedResponse);\n\n    // when\n    ResponseEntity<com.myhome.model.SchedulePaymentResponse> responseEntity =\n        paymentController.listPaymentDetails(TEST_ID);\n\n    // then\n    assertEquals(HttpStatus.OK, responseEntity.getStatusCode());\n    assertEquals(expectedResponse, responseEntity.getBody());\n    verify(paymentService).getPaymentDetails(TEST_ID);\n    verify(paymentApiMapper).paymentToSchedulePaymentResponse(paymentDto);\n  }\n\n  @Test\n  void shouldListNoPaymentDetailsSuccess() {\n    //given\n    given(paymentService.getPaymentDetails(TEST_ID))\n        .willReturn(Optional.empty());\n\n    //when\n    ResponseEntity<com.myhome.model.SchedulePaymentResponse> responseEntity =\n        paymentController.listPaymentDetails(TEST_ID);\n\n    //then\n    assertEquals(HttpStatus.NOT_FOUND, responseEntity.getStatusCode());\n    assertNull(responseEntity.getBody());\n    verify(paymentService).getPaymentDetails(TEST_ID);\n    verifyNoInteractions(paymentApiMapper);\n  }\n\n  @Test\n  void shouldGetNoMemberPaymentsSuccess() {\n    //given\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.empty());\n\n    //when\n    ResponseEntity<ListMemberPaymentsResponse> responseEntity =\n        paymentController.listAllMemberPayments(TEST_MEMBER_ID);\n\n    //then\n    assertEquals(HttpStatus.NOT_FOUND, responseEntity.getStatusCode());\n    assertNull(responseEntity.getBody());\n    verifyNoInteractions(paymentApiMapper);\n  }\n\n  @Test\n  void shouldGetMemberPaymentsSuccess() {\n    // given\n    PaymentDto paymentDto = createTestPaymentDto();\n\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n\n    HouseMember member = new HouseMember(TEST_MEMBER_ID, null, TEST_MEMBER_NAME, null);\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.of(member));\n\n    Set<Payment> payments = new HashSet<>();\n    Payment mockPayment = getMockPayment();\n    payments.add(mockPayment);\n\n    given(paymentService.getPaymentsByMember(TEST_MEMBER_ID))\n        .willReturn(payments);\n\n    Set<MemberPayment> paymentResponses = new HashSet<>();\n    paymentResponses.add(\n        new MemberPayment()\n            .memberId(TEST_MEMBER_ID)\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE));\n\n    ListMemberPaymentsResponse expectedResponse =\n        new ListMemberPaymentsResponse().payments(paymentResponses);\n\n    given(paymentApiMapper.memberPaymentSetToRestApiResponseMemberPaymentSet(payments))\n        .willReturn(paymentResponses);\n\n    // when\n    ResponseEntity<ListMemberPaymentsResponse> responseEntity =\n        paymentController.listAllMemberPayments(TEST_MEMBER_ID);\n\n    // then\n    assertEquals(HttpStatus.OK, responseEntity.getStatusCode());\n    assertEquals(responseEntity.getBody(), expectedResponse);\n    verify(paymentService).getPaymentsByMember(TEST_MEMBER_ID);\n    verify(paymentApiMapper).memberPaymentSetToRestApiResponseMemberPaymentSet(payments);\n  }\n\n  @Test\n  void shouldGetAdminPaymentsSuccess() {\n    // given\n    com.myhome.model.SchedulePaymentRequest request =\n        new com.myhome.model.SchedulePaymentRequest()\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    PaymentDto paymentDto = createTestPaymentDto();\n\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n\n    List<Payment> payments = new ArrayList<>();\n    Payment mockPayment = getMockPayment();\n    payments.add(mockPayment);\n\n    Set<String> adminIds = new HashSet<>();\n    adminIds.add(TEST_ADMIN_ID);\n\n    Set<User> admins = new HashSet<>();\n\n    Community community = getMockCommunity(admins);\n\n    CommunityDto communityDto = createTestCommunityDto();\n\n    given(communityService.createCommunity(communityDto))\n        .willReturn(community);\n    given(communityService.getCommunityDetailsByIdWithAdmins(TEST_ID))\n        .willReturn(Optional.of(community));\n    given(paymentService.getPaymentsByAdmin(TEST_ADMIN_ID, TEST_PAGEABLE))\n        .willReturn(new PageImpl<>(payments));\n    given(communityService.addAdminsToCommunity(TEST_ID, adminIds))\n        .willReturn(Optional.of(community));\n\n    Set<AdminPayment> responsePayments = new HashSet<>();\n    responsePayments.add(\n        new AdminPayment().adminId(TEST_ADMIN_ID)\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n    );\n\n    ListAdminPaymentsResponse expectedResponse =\n        new ListAdminPaymentsResponse()\n            .payments(responsePayments)\n            .pageInfo(PageInfo.of(TEST_PAGEABLE, new PageImpl<>(payments)));\n\n    given(paymentApiMapper.adminPaymentSetToRestApiResponseAdminPaymentSet(new HashSet<>(payments)))\n        .willReturn(responsePayments);\n\n    //when\n    ResponseEntity<ListAdminPaymentsResponse> responseEntity =\n        paymentController.listAllAdminScheduledPayments(TEST_ID, TEST_ADMIN_ID,\n            TEST_PAGEABLE);\n\n    //then\n    assertEquals(HttpStatus.OK, responseEntity.getStatusCode());\n    assertEquals(expectedResponse, responseEntity.getBody());\n    verify(communityService).getCommunityDetailsByIdWithAdmins(TEST_ID);\n    verify(paymentService).getPaymentsByAdmin(TEST_ADMIN_ID, TEST_PAGEABLE);\n    verify(paymentApiMapper).adminPaymentSetToRestApiResponseAdminPaymentSet(\n        new HashSet<>(payments));\n  }\n\n  @Test\n  void shouldReturnNotFoundWhenAdminIsNotInCommunity() {\n    //given\n    final String notAdminFromCommunity = \"2\";\n    Community community = getMockCommunity(new HashSet<>());\n    given(communityService.getCommunityDetailsByIdWithAdmins(TEST_ID))\n        .willReturn(Optional.of(community));\n\n    //when\n    ResponseEntity<ListAdminPaymentsResponse> responseEntity =\n        paymentController.listAllAdminScheduledPayments(TEST_ID, notAdminFromCommunity,\n            TEST_PAGEABLE);\n\n    //then\n    assertEquals(HttpStatus.NOT_FOUND, responseEntity.getStatusCode());\n    assertNull(responseEntity.getBody());\n    verify(communityService).getCommunityDetailsByIdWithAdmins(TEST_ID);\n    verifyNoInteractions(paymentService);\n  }\n\n  @Test\n  void shouldThrowExceptionWhenCommunityNotExists() {\n    //given\n    String expectedExceptionMessage = \"Community with given id not exists: \" + TEST_ID;\n\n    given(communityService.getCommunityDetailsByIdWithAdmins(TEST_ID))\n        .willReturn(Optional.empty());\n\n    //when\n    final RuntimeException runtimeException = assertThrows(\n        RuntimeException.class,\n        () -> paymentController.listAllAdminScheduledPayments(TEST_ID, TEST_ADMIN_ID,\n            TEST_PAGEABLE)\n    );\n\n    //then\n    assertEquals(expectedExceptionMessage, runtimeException.getMessage());\n    verify(communityService).getCommunityDetailsByIdWithAdmins(TEST_ID);\n    verifyNoInteractions(paymentService);\n    verifyNoInteractions(paymentApiMapper);\n  }\n}","location":{"start":65,"insert":65,"offset":" ","indent":0,"comment":null},"item_type":"class","length":534},{"id":"29361a97-eb1c-75bb-7a4c-a64245369156","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"initializes MockitoAnnotations for testing purposes by mocking dependencies and setting up the Mockito runtime environment.","params":[],"usage":{"language":"java","code":"import org.mockito.Mock;\nimport static org.mockito.MockitoAnnotations.initMocks;\n\n@RunWith(JUnitPlatform.class)\npublic class MyTest {\n  @Mock private MyService mockService;\n\n  @BeforeEach\n  void init() {\n    initMocks(this);\n  }\n}\n","description":"\nIn this example, the `initMocks` method is called in a `@BeforeEach` method annotated with the `@BeforeAll` annotation. This sets up the mocks for all the fields annotated with `@Mock` in the test class. It also performs some other important operations such as initializing the mocking infrastructure, and setting up the default answer for mock objects.\n\nFor example, in this test case, we have a field annotated with `@Mock` called `mockService`, which is a mock of the `MyService` class. We initialize this mock using the `initMocks` method in the `@BeforeEach` method, which sets up the mock and initializes it with some default values.\n\nAlso, note that we have used the `@RunWith(JUnitPlatform.class)` annotation to indicate that this test is run with JUnit Platform. This is not necessary, but it makes the test more concise and easier to read."},"name":"init","code":"@BeforeEach\n  private void init() {\n    MockitoAnnotations.initMocks(this);\n  }","location":{"start":102,"insert":102,"offset":" ","indent":2,"comment":null},"item_type":"method","length":4},{"id":"67ba41e9-8a9e-558c-1e47-485a79f8d6b9","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"creates a PaymentDto object with test data, including an ID, type, description, charge, due date, and recurring status, as well as reference to a UserDto and HouseMemberDto objects representing the admin and member associated with the payment.","params":[],"returns":{"type_name":"PaymentDto","description":"a `PaymentDto` object with mock data for a payment.\n\n* paymentId: A unique identifier for the payment.\n* type: The type of payment (e.g., invoice, subscription).\n* description: A brief description of the payment.\n* charge: The amount to be charged to the user.\n* dueDate: The date by which the payment must be made.\n* recurring: Whether the payment is recurring or not.\n* admin: The user who created the payment (represented as a `UserDto`).\n* member: The member associated with the payment (represented as a `HouseMemberDto`).","complex_type":true},"usage":{"language":"java","code":"User admin = new User();\nadmin.setId(Long.valueOf(TEST_ADMIN_ID));\nadmin.setCommunityIds(new HashSet<>(Collections.singletonList(TEST_COMMUNITY_ID)));\nadmin.setName(TEST_ADMIN_NAME);\nadmin.setEmail(TEST_ADMIN_EMAIL);\n\nUser member = new User();\nmember.setId(Long.valueOf(TEST_MEMBER_ID));\nmember.setName(TEST_MEMBER_NAME);\n\nPaymentDto paymentDto = createTestPaymentDto();\npaymentDto.setAdmin(admin);\npaymentDto.setMember(member);\n","description":"\nIn this example, we are creating two users, one admin and the other member, and then using the createTestPaymentDto method to create a payment with the admin and member details set. The resulting paymentDto object would contain the test values for the admin and member ids."},"name":"createTestPaymentDto","code":"private PaymentDto createTestPaymentDto() {\n    UserDto userDto = UserDto.builder()\n        .userId(TEST_ADMIN_ID)\n        .communityIds(new HashSet<>(Collections.singletonList(TEST_COMMUNITY_ID)))\n        .id(Long.valueOf(TEST_ADMIN_ID))\n        .encryptedPassword(TEST_ADMIN_PASSWORD)\n        .name(TEST_ADMIN_NAME)\n        .email(TEST_ADMIN_EMAIL)\n        .build();\n    HouseMemberDto houseMemberDto = new HouseMemberDto()\n        .memberId(TEST_MEMBER_ID)\n        .name(TEST_MEMBER_NAME)\n        .id(Long.valueOf(TEST_MEMBER_ID));\n\n    return PaymentDto.builder()\n        .paymentId(TEST_ID)\n        .type(TEST_TYPE)\n        .description(TEST_DESCRIPTION)\n        .charge(TEST_CHARGE)\n        .dueDate(TEST_DUE_DATE)\n        .recurring(TEST_RECURRING)\n        .admin(userDto)\n        .member(houseMemberDto)\n        .build();\n  }","location":{"start":107,"insert":107,"offset":" ","indent":2,"comment":null},"item_type":"method","length":25},{"id":"f276dd86-7f9d-23bf-704e-37aecec1d23b","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"creates a new instance of the `CommunityDto` class with test data for a community, including its name, district, and ID.","params":[],"returns":{"type_name":"CommunityDto","description":"a `CommunityDto` object with test data.\n\n* `name`: A string representing the name of the community.\n* `district`: A string representing the district where the community is located.\n* `communityId`: An integer representing the unique identifier of the community.","complex_type":true},"usage":{"language":"java","code":"@Test\nvoid testCreateCommunity() {\n    CommunityDto communityDto = paymentController.createCommunity(createTestCommunityDto());\n    // assert statements about the created community go here\n}\n","description":"\nIn this example, a new community is being created using createTestCommunityDto and then the newly created community is tested by asserting various properties of it.  The test would likely have additional code to check for errors or exceptions that may be thrown during creation."},"name":"createTestCommunityDto","code":"private CommunityDto createTestCommunityDto() {\n    CommunityDto communityDto = new CommunityDto();\n    communityDto.setName(TEST_COMMUNITY_NAME);\n    communityDto.setDistrict(TEST_COMMUNITY_DISTRICT);\n    communityDto.setCommunityId(TEST_COMMUNITY_ID);\n    return communityDto;\n  }","location":{"start":133,"insert":133,"offset":" ","indent":2,"comment":null},"item_type":"method","length":7},{"id":"06fd184d-5f71-8ba8-924a-51f585f6a741","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"creates a new community object and adds admins to it, then links the admin to the community via a house object, finally returning the created community object.","params":[{"name":"admins","type_name":"Set<User>","description":"set of users who will be administrators for the generated community, and it is used to create an instance of `User` objects that will be added as admins to the community.\n\n* `Set<User> admins`: This is a set of `User` objects, representing the community administrators.\n* `new HashSet<>()`: An empty set, used as a placeholder for the community's administrators.\n* `TEST_COMMUNITY_NAME`, `TEST_COMMUNITY_ID`, and `TEST_COMMUNITY_DISTRICT`: These are constant strings representing the name, ID, and district of the mock community being created.\n* `new HashSet<>()`: An empty set, used to store the community's houses.\n* `User admin`: A single `User` object representing the first administrator for the community. Its properties are explained below:\n\t+ `COMMUNITY_ADMIN_NAME`: A constant string representing the name of the community administrator.\n\t+ `TEST_ADMIN_ID`: An integer ID representing the ID of the community administrator.\n\t+ `COMMUNITY_ADMIN_EMAIL`: An email address representing the email address of the community administrator.\n\t+ `false`: A boolean value indicating whether the administrator is an owner of the community.\n\t+ `COMMUNITY_ADMIN_PASSWORD`: A password representing the password of the community administrator.\n\t+ `new HashSet<>()`: An empty set, used to store the communities that the administrator belongs to.\n\t+ `new HashSet<>()`: An empty set, used to store the houses that the administrator owns.","complex_type":true}],"returns":{"type_name":"","description":"a mock community object containing admins and houses.\n\n* The `Community` object represents a mock community with a set of admins, a name, an ID, a district, and a set of houses.\n* The `admins` field is a set of users who are administrators of the community.\n* The `name`, `id`, and `district` fields represent the name, ID, and district of the community, respectively.\n* The `houses` field is a set of `CommunityHouse` objects that represent the houses in the community.\n* The `User` object represents an admin user of the community with a name, ID, email, and password.\n* The `getAdmins()` method returns a set of admins for the community.\n* The `getHouses()` method returns a set of houses in the community.\n* The `setCommunity()` method sets the community object for the given house.","complex_type":true},"usage":{"language":"java","code":"Set<User> admins = new HashSet<>();\nUser admin1 = new User(\"admin\", \"id1\", \"email1\", false, \"password\", new HashSet<>(), new HashSet<>());\nadmins.add(admin1);\nCommunity community = getMockCommunity(admins);\n","description":"\nIn this example, we create a new set of users and add one user to it using the `add()` method on the set. We then pass this set as an argument to the `getMockCommunity` method to create a mock Community object with that single admin in it. This mock Community object can be used for other purposes such as testing the community service's functionality with the created mock community.\n\nThe above example is not a unit test but an integration test of the `getMockCommunity` method. The purpose of this method is to create a mock community object that can be used to simulate the behavior of the CommunityService in various scenarios. In order to make sure the method works correctly, we need to test the functionality of the CommunityService with different inputs and check if it returns the expected output for each input."},"name":"getMockCommunity","code":"private Community getMockCommunity(Set<User> admins) {\n    Community community =\n        new Community(admins, new HashSet<>(), TEST_COMMUNITY_NAME, TEST_COMMUNITY_ID,\n            TEST_COMMUNITY_DISTRICT, new HashSet<>());\n    User admin = new User(COMMUNITY_ADMIN_NAME, TEST_ADMIN_ID, COMMUNITY_ADMIN_EMAIL, false,\n        COMMUNITY_ADMIN_PASSWORD, new HashSet<>(), new HashSet<>());\n    community.getAdmins().add(admin);\n    admin.getCommunities().add(community);\n\n    CommunityHouse communityHouse = getMockCommunityHouse();\n    communityHouse.setCommunity(community);\n    community.getHouses().add(communityHouse);\n\n    return community;\n  }","location":{"start":141,"insert":141,"offset":" ","indent":2,"comment":null},"item_type":"method","length":15},{"id":"98e48734-7c2f-38a9-9e42-412a39250897","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"creates a new instance of `CommunityHouse` and sets its name, ID, and member list to empty. It returns the created `CommunityHouse` object.","params":[],"returns":{"type_name":"CommunityHouse","description":"a mock CommunityHouse object.\n\n* `CommunityHouse communityHouse`: This is an instance of the `CommunityHouse` class, which contains information about a mock community house.\n* `name`: The name of the community house, set to `COMMUNITY_HOUSE_NAME`.\n* `houseId`: The ID of the community house, set to `COMMUNITY_HOUSE_ID`.\n* `houseMembers`: A set containing no members, indicating that the community house has no members.","complex_type":true},"usage":{"language":"java","code":"public class CommunityHouseTest {\n    private final CommunityHouse communityHouse = new CommunityHouse();\n    @Test\n    public void testGetName() {\n        assertEquals(COMMUNITY_HOUSE_NAME, communityHouse.getName());\n    }\n\n    @Test\n    public void testGetId() {\n        assertEquals(COMMUNITY_HOUSE_ID, communityHouse.getHouseId());\n    }\n}\n","description":"\nIn this example, the getMockCommunityHouse method is called and used to create an instance of CommunityHouse that will be tested. The testGetName() and testGetId() methods are used to verify if the name and house id fields of the CommunityHouse instance created in the previous step match their expected values.\n\nThe getMockCommunityHouse method is not a unit test example, but an integration test example since it uses other classes. The method creates a new CommunityHouse object with some initial data that will be used to test the methods of the class. This way we can check if the name and id values are correctly set.\n\nThe getMockCommunityHouse method is not explained, but its purpose is to create an instance of CommunityHouse for testing purposes. The example shows how it would be called in a unit test scenario and what tests would be run on it."},"name":"getMockCommunityHouse","code":"private CommunityHouse getMockCommunityHouse() {\n    CommunityHouse communityHouse = new CommunityHouse();\n    communityHouse.setName(COMMUNITY_HOUSE_NAME);\n    communityHouse.setHouseId(COMMUNITY_HOUSE_ID);\n    communityHouse.setHouseMembers(new HashSet<>());\n\n    return communityHouse;\n  }","location":{"start":157,"insert":157,"offset":" ","indent":2,"comment":null},"item_type":"method","length":8},{"id":"1dedc286-2210-c49f-8845-be93368db5ea","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"creates a mock payment object containing a user, community, and payment details. The user is created with admin privileges, and the community is generated with the user as an admin. The function returns the mock payment object.","params":[],"returns":{"type_name":"Payment","description":"a mock payment object containing various details.\n\n* `id`: The unique identifier for this payment.\n* `charge`: The amount charged to the customer.\n* `type`: The type of payment (e.g., one-time or recurring).\n* `description`: A brief description of the payment.\n* `dueDate`: The date by which the payment is due.\n* `admin`: The user who created the payment.\n* `houseMember`: The member associated with this payment.\n* `communityHouse`: The community house associated with this payment.","complex_type":true},"usage":{"language":"java","code":"private Payment getMockPayment() {\n    User admin = new User(TEST_ADMIN_NAME, TEST_ADMIN_ID, TEST_ADMIN_EMAIL, false, TEST_ADMIN_PASSWORD, new HashSet<>(), new HashSet<>());\n    Community community = getMockCommunity(new HashSet<>());\n    community.getAdmins().add(admin);\n    admin.getCommunities().add(community);\n    return new Payment(TEST_ID, TEST_CHARGE, TEST_TYPE, TEST_DESCRIPTION, TEST_RECURRING, LocalDate.parse(TEST_DUE_DATE, DateTimeFormatter.ofPattern(\"yyyy-MM-dd\")), admin, new HouseMember(TEST_MEMBER_ID, new HouseMemberDocument(), TEST_MEMBER_NAME, new CommunityHouse()));\n}\n","description":"\nExplanation:\n\nThe getMockPayment method returns a Payment object with the following details:\n\n* Payment ID (TEST_ID)\n* Charge (TEST_CHARGE)\n* Type (TEST_TYPE)\n* Description (TEST_DESCRIPTION)\n* Recurring (TEST_RECURRING)\n* Due date (LocalDate.parse(TEST_DUE_DATE, DateTimeFormatter.ofPattern(\"yyyy-MM-dd\")))\n* Admin (the user object created using the getMockCommunity method)\n* Member (a HouseMember object with the following details:\n  * ID (TEST_MEMBER_ID)\n  * Name (TEST_MEMBER_NAME)\n  * Community house (a new CommunityHouse object)\n\nThe method creates a user admin, adds it to the community created using the getMockCommunity method, and then returns a Payment object with all the details mentioned above."},"name":"getMockPayment","code":"private Payment getMockPayment() {\n    User admin =\n        new User(TEST_ADMIN_NAME, TEST_ADMIN_ID, TEST_ADMIN_EMAIL, false, TEST_ADMIN_PASSWORD,\n            new HashSet<>(), new HashSet<>());\n    Community community = getMockCommunity(new HashSet<>());\n    community.getAdmins().add(admin);\n    admin.getCommunities().add(community);\n    return new Payment(TEST_ID, TEST_CHARGE, TEST_TYPE, TEST_DESCRIPTION, TEST_RECURRING,\n        LocalDate.parse(TEST_DUE_DATE, DateTimeFormatter.ofPattern(\"yyyy-MM-dd\")), admin,\n        new HouseMember(TEST_MEMBER_ID, new HouseMemberDocument(), TEST_MEMBER_NAME,\n            new CommunityHouse()));\n  }","location":{"start":166,"insert":166,"offset":" ","indent":2,"comment":null},"item_type":"method","length":12},{"id":"9738c1b7-e1b7-8fbe-1f45-219f56d7ec7a","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"tests the payment API endpoint for scheduling a payment successfully. It creates a test request, enriches it with additional data, and then verifies that the response is successful and the data is correct.","params":[],"usage":{"language":"java","code":"@Test\n  void shouldSchedulePaymentSuccessful() {\n    // given\n    com.myhome.model.SchedulePaymentRequest request =\n        new com.myhome.model.SchedulePaymentRequest()\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n\n    EnrichedSchedulePaymentRequest enrichedRequest =\n        new EnrichedSchedulePaymentRequest(TEST_TYPE, TEST_DESCRIPTION, TEST_RECURRING, TEST_CHARGE,\n            TEST_DUE_DATE, TEST_ADMIN_ID, 1L, TEST_ADMIN_NAME, TEST_ADMIN_EMAIL,\n            TEST_ADMIN_PASSWORD, new HashSet<>(Collections.singletonList(TEST_COMMUNITY_ID)),\n            TEST_MEMBER_ID,\n            2L, \"\", TEST_MEMBER_NAME, COMMUNITY_HOUSE_ID);\n    PaymentDto paymentDto = createTestPaymentDto();\n    com.myhome.model.SchedulePaymentResponse response =\n        new com.myhome.model.SchedulePaymentResponse()\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n\n    Community community = getMockCommunity(new HashSet<>());\n\n    HouseMember member = new HouseMember(TEST_MEMBER_ID, null, TEST_MEMBER_NAME,\n        community.getHouses().iterator().next());\n\n    community.getHouses().iterator().next().getHouseMembers().add(member);\n\n    User admin = community.getAdmins().iterator().next();\n\n    given(paymentApiMapper.enrichSchedulePaymentRequest(request, admin, member))\n        .willReturn(enrichedRequest);\n    given(paymentApiMapper.enrichedSchedulePaymentRequestToPaymentDto(enrichedRequest))\n        .willReturn(paymentDto);\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n    given(paymentApiMapper.paymentToSchedulePaymentResponse(paymentDto))\n        .willReturn(response);\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.of(member));\n    given(communityService.findCommunityAdminById(TEST_ADMIN_ID))\n        .willReturn(Optional.of(community.getAdmins().iterator().next()));\n\n    //when\n    ResponseEntity<com.myhome.model.SchedulePaymentResponse> responseEntity =\n        paymentController.schedulePayment(request);\n\n    //then\n    assertEquals(HttpStatus.CREATED, responseEntity.getStatusCode());\n    assertEquals(response, responseEntity.getBody());\n    verify(paymentApiMapper).enrichSchedulePaymentRequest(request, admin, member);\n    verify(paymentApiMapper).enrichedSchedulePaymentRequestToPaymentDto(enrichedRequest);\n    verify(paymentService).schedulePayment(paymentDto);\n    verify(paymentApiMapper).paymentToSchedulePaymentResponse(paymentDto);\n    verify(paymentService).getHouseMember(TEST_MEMBER_ID);\n  }\n","description":"\nThis example is a unit test for the method `shouldSchedulePaymentSuccessful` that uses JUnit to test that the code in this method works correctly. The method being tested is the controller method, `schedulePayment`, which takes as input a `com.myhome.model.SchedulePaymentRequest` and returns an instance of `ResponseEntity<com.myhome.model.SchedulePaymentResponse>`.\nThis test first creates instances of the objects that are needed to run this method, including a mocked version of the service that is being used in the method, an instance of `EnrichedSchedulePaymentRequest` and a `PaymentDto`, which is what the method returns. It then sets up expectations on those mocks using JUnit's `given` annotation to specify the inputs and outputs of those methods.\nIt also specifies that if the method being tested is called, it should return a response with a status code of `HttpStatus.CREATED` and the same instance of `com.myhome.model.SchedulePaymentResponse` as the body of the response. Finally, the test verifies the behavior of the controller by making sure that when it receives an instance of `SchedulePaymentRequest` as input to the method being tested, it returns a response with those same values for both status code and response body.\nThis test also has expectations on the mocked version of the service being used in the method, which is specified using JUnit's `verify` annotation. This means that when the mocked service is called to perform some action, it must be called with those same inputs as were provided by the caller of this method."},"name":"shouldSchedulePaymentSuccessful","code":"@Test\n  void shouldSchedulePaymentSuccessful() {\n    // given\n    com.myhome.model.SchedulePaymentRequest request =\n        new com.myhome.model.SchedulePaymentRequest()\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n\n    EnrichedSchedulePaymentRequest enrichedRequest =\n        new EnrichedSchedulePaymentRequest(TEST_TYPE, TEST_DESCRIPTION, TEST_RECURRING, TEST_CHARGE,\n            TEST_DUE_DATE, TEST_ADMIN_ID, 1L, TEST_ADMIN_NAME, TEST_ADMIN_EMAIL,\n            TEST_ADMIN_PASSWORD, new HashSet<>(Collections.singletonList(TEST_COMMUNITY_ID)),\n            TEST_MEMBER_ID,\n            2L, \"\", TEST_MEMBER_NAME, COMMUNITY_HOUSE_ID);\n    PaymentDto paymentDto = createTestPaymentDto();\n    com.myhome.model.SchedulePaymentResponse response =\n        new com.myhome.model.SchedulePaymentResponse()\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n\n    Community community = getMockCommunity(new HashSet<>());\n\n    HouseMember member = new HouseMember(TEST_MEMBER_ID, null, TEST_MEMBER_NAME,\n        community.getHouses().iterator().next());\n\n    community.getHouses().iterator().next().getHouseMembers().add(member);\n\n    User admin = community.getAdmins().iterator().next();\n\n    given(paymentApiMapper.enrichSchedulePaymentRequest(request, admin, member))\n        .willReturn(enrichedRequest);\n    given(paymentApiMapper.enrichedSchedulePaymentRequestToPaymentDto(enrichedRequest))\n        .willReturn(paymentDto);\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n    given(paymentApiMapper.paymentToSchedulePaymentResponse(paymentDto))\n        .willReturn(response);\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.of(member));\n    given(communityService.findCommunityAdminById(TEST_ADMIN_ID))\n        .willReturn(Optional.of(community.getAdmins().iterator().next()));\n\n    //when\n    ResponseEntity<com.myhome.model.SchedulePaymentResponse> responseEntity =\n        paymentController.schedulePayment(request);\n\n    //then\n    assertEquals(HttpStatus.CREATED, responseEntity.getStatusCode());\n    assertEquals(response, responseEntity.getBody());\n    verify(paymentApiMapper).enrichSchedulePaymentRequest(request, admin, member);\n    verify(paymentApiMapper).enrichedSchedulePaymentRequestToPaymentDto(enrichedRequest);\n    verify(paymentService).schedulePayment(paymentDto);\n    verify(paymentApiMapper).paymentToSchedulePaymentResponse(paymentDto);\n    verify(paymentService).getHouseMember(TEST_MEMBER_ID);\n  }","location":{"start":179,"insert":179,"offset":" ","indent":2,"comment":null},"item_type":"method","length":66},{"id":"5944dd48-9c12-5fa2-6c4e-127919b423bb","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"tests whether the payment controller throws a `RuntimeException` when a member with the given ID does not exist in the database.","params":[],"usage":{"language":"java","code":"@Test\n  void shouldNotScheduleIfMemberDoesNotExist() {\n    // given\n    com.myhome.model.SchedulePaymentRequest request =\n        new com.myhome.model.SchedulePaymentRequest()\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    PaymentDto paymentDto = createTestPaymentDto();\n    String expectedExceptionMessage = \"House member with given id not exists: \" + TEST_MEMBER_ID;\n\n    given(paymentApiMapper.schedulePaymentRequestToPaymentDto(request))\n        .willReturn(paymentDto);\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.empty());\n\n    // when\n    final RuntimeException runtimeException =\n        assertThrows(RuntimeException.class, () -> paymentController.schedulePayment(request));\n    // then\n    final String exceptionMessage = runtimeException.getMessage();\n    assertEquals(expectedExceptionMessage, exceptionMessage);\n    verifyNoInteractions(paymentApiMapper);\n  }\n","description":"\nIn this example, a request object is created and passed into the schedulePayment method of the payment controller. The method will convert the request object to a PaymentDto and then pass it to the schedulePayment method of the payment service. The method will also get the member with the specified ID from the payment service using the getHouseMember method. If the member does not exist, an exception is thrown and caught in the test method. Finally, the exception message is asserted to equal the expectedExceptionMessage."},"name":"shouldNotScheduleIfMemberDoesNotExist","code":"@Test\n  void shouldNotScheduleIfMemberDoesNotExist() {\n    // given\n    com.myhome.model.SchedulePaymentRequest request =\n        new com.myhome.model.SchedulePaymentRequest()\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    PaymentDto paymentDto = createTestPaymentDto();\n    String expectedExceptionMessage = \"House member with given id not exists: \" + TEST_MEMBER_ID;\n\n    given(paymentApiMapper.schedulePaymentRequestToPaymentDto(request))\n        .willReturn(paymentDto);\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.empty());\n\n    // when\n    final RuntimeException runtimeException =\n        assertThrows(RuntimeException.class, () -> paymentController.schedulePayment(request));\n    // then\n    final String exceptionMessage = runtimeException.getMessage();\n    assertEquals(expectedExceptionMessage, exceptionMessage);\n    verifyNoInteractions(paymentApiMapper);\n  }","location":{"start":246,"insert":246,"offset":" ","indent":2,"comment":null},"item_type":"method","length":30},{"id":"a04c0823-f4f2-8fab-9b48-6f091bc6ef8b","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"tests the scenario where an admin with the given ID does not exist, and it should throw a `RuntimeException` with a specific message.","params":[],"usage":{"language":"java","code":"@Test\n  void shouldNotScheduleIfAdminDoesntExist() {\n    // given\n    com.myhome.model.SchedulePaymentRequest request =\n        new com.myhome.model.SchedulePaymentRequest()\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    PaymentDto paymentDto = createTestPaymentDto();\n    String expectedExceptionMessage = \"Admin with given id not exists: \" + TEST_ADMIN_ID;\n    com.myhome.model.SchedulePaymentResponse response =\n        new com.myhome.model.SchedulePaymentResponse()\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    HouseMember member = new HouseMember(TEST_MEMBER_ID, null, TEST_MEMBER_NAME, null);\n\n    given(paymentApiMapper.schedulePaymentRequestToPaymentDto(request))\n        .willReturn(paymentDto);\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n    given(paymentApiMapper.paymentToSchedulePaymentResponse(paymentDto))\n        .willReturn(response);\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.of(member));\n    given(communityService.findCommunityAdminById(TEST_ADMIN_ID))\n        .willReturn(Optional.empty());\n\n    // when\n    final RuntimeException runtimeException =\n        assertThrows(RuntimeException.class, () -> paymentController.schedulePayment(request));\n    // then\n    final String exceptionMessage = runtimeException.getMessage();\n    assertEquals(expectedExceptionMessage, exceptionMessage);\n    verifyNoInteractions(paymentApiMapper);\n  }\n","description":"\n The example code should be as short as possible and only contain the necessary parts of the code to show how method would be used.     The code should be readable and understandable without any unnecessary or incorrect inputs.     Do not provide an explanation on how to use a java method, do not explain your code, do not create a unit test example, hallucinate incorrect inputs.\n\n\n\n\nThe following is an example on how the method shouldNotScheduleIfAdminDoesntExist would be used:\n"},"name":"shouldNotScheduleIfAdminDoesntExist","code":"@Test\n  void shouldNotScheduleIfAdminDoesntExist() {\n    // given\n    com.myhome.model.SchedulePaymentRequest request =\n        new com.myhome.model.SchedulePaymentRequest()\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    PaymentDto paymentDto = createTestPaymentDto();\n    String expectedExceptionMessage = \"Admin with given id not exists: \" + TEST_ADMIN_ID;\n    com.myhome.model.SchedulePaymentResponse response =\n        new com.myhome.model.SchedulePaymentResponse()\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n\n    HouseMember member = new HouseMember(TEST_MEMBER_ID, null, TEST_MEMBER_NAME, null);\n\n    given(paymentApiMapper.schedulePaymentRequestToPaymentDto(request))\n        .willReturn(paymentDto);\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n    given(paymentApiMapper.paymentToSchedulePaymentResponse(paymentDto))\n        .willReturn(response);\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.of(member));\n    given(communityService.findCommunityAdminById(TEST_ADMIN_ID))\n        .willReturn(Optional.empty());\n\n    // when\n    final RuntimeException runtimeException =\n        assertThrows(RuntimeException.class, () -> paymentController.schedulePayment(request));\n    // then\n    final String exceptionMessage = runtimeException.getMessage();\n    assertEquals(expectedExceptionMessage, exceptionMessage);\n    verifyNoInteractions(paymentApiMapper);\n  }","location":{"start":277,"insert":277,"offset":" ","indent":2,"comment":null},"item_type":"method","length":46},{"id":"130b9f5e-3668-2491-8a48-15d2d7fd21f8","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"checks if a payment request should be scheduled when the admin associated with the member is not part of the community. If the admin is not in the community, the function returns a ResponseEntity with a status code of NOT_FOUND and an empty body.","params":[],"usage":{"language":"java","code":"@Test\n  void shouldNotScheduleIfAdminIsNotInCommunity() {\n    // given\n    com.myhome.model.SchedulePaymentRequest request =\n        new com.myhome.model.SchedulePaymentRequest()\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    PaymentDto paymentDto = createTestPaymentDto();\n    com.myhome.model.SchedulePaymentResponse response =\n        new com.myhome.model.SchedulePaymentResponse()\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    Community community = getMockCommunity();\n    User admin = community.getAdmins().iterator().next();\n    community.getAdmins().remove(admin);\n    HouseMember member = new HouseMember(TEST_MEMBER_ID, null, TEST_MEMBER_NAME, communityHouse);\n\n    given(paymentApiMapper.schedulePaymentRequestToPaymentDto(request))\n        .willReturn(paymentDto);\n\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n\n    given(paymentApiMapper.paymentToSchedulePaymentResponse(paymentDto))\n        .willReturn(response);\n\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.of(member));\n\n    given(communityService.findCommunityAdminById(TEST_ADMIN_ID))\n        .willReturn(Optional.of(admin));\n\n    // when\n    ResponseEntity<com.myhome.model.SchedulePaymentResponse> responseEntity = paymentController.schedulePayment(request);\n\n    // then\n    assertEquals(HttpStatus.NOT_FOUND, responseEntity.getStatusCode());\n    assertNull(responseEntity.getBody());\n\n    verify(paymentService).getHouseMember(TEST_MEMBER_ID);\n    verifyNoInteractions(paymentApiMapper);\n    verify(communityService).findCommunityAdminById(TEST_ADMIN_ID);\n  }\n","description":"\nThe code should be short and readable. It is supposed to show how the method shouldNotScheduleIfAdminIsNotInCommunity() would be used. The example code should work correctly. Do not create a unit test example, do not hallucinate incorrect inputs, do not explain your code."},"name":"shouldNotScheduleIfAdminIsNotInCommunity","code":"@Test\n  void shouldNotScheduleIfAdminIsNotInCommunity() {\n    // given\n    com.myhome.model.SchedulePaymentRequest request =\n        new com.myhome.model.SchedulePaymentRequest()\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    PaymentDto paymentDto = createTestPaymentDto();\n    com.myhome.model.SchedulePaymentResponse response =\n        new com.myhome.model.SchedulePaymentResponse()\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n\n    Community community = getMockCommunity(new HashSet<>());\n    Set<User> admins = community.getAdmins();\n    User admin = admins.iterator().next();\n    admins.remove(admin);\n\n    CommunityHouse communityHouse = community.getHouses().iterator().next();\n\n    HouseMember member = new HouseMember(TEST_MEMBER_ID, null, TEST_MEMBER_NAME, communityHouse);\n\n    given(paymentApiMapper.schedulePaymentRequestToPaymentDto(request))\n        .willReturn(paymentDto);\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n    given(paymentApiMapper.paymentToSchedulePaymentResponse(paymentDto))\n        .willReturn(response);\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.of(member));\n    given(communityService.findCommunityAdminById(TEST_ADMIN_ID))\n        .willReturn(Optional.of(admin));\n\n    //when\n    ResponseEntity<com.myhome.model.SchedulePaymentResponse> responseEntity =\n        paymentController.schedulePayment(request);\n\n    //then\n    assertEquals(HttpStatus.NOT_FOUND, responseEntity.getStatusCode());\n    assertNull(responseEntity.getBody());\n    verify(paymentService).getHouseMember(TEST_MEMBER_ID);\n    verifyNoInteractions(paymentApiMapper);\n    verify(communityService).findCommunityAdminById(TEST_ADMIN_ID);\n  }","location":{"start":324,"insert":324,"offset":" ","indent":2,"comment":null},"item_type":"method","length":55},{"id":"ca45403c-1fb5-bda4-7940-048fa9d0cb72","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"tests the payment controller's method `listPaymentDetails`, which retrieves payment details for a given ID and maps them to a `SchedulePaymentResponse` object. The function verifies that the response status code is `OK` and that the mapped response matches the expected response.","params":[],"usage":{"language":"java","code":"@Test\n  void shouldGetPaymentDetailsSuccess() {\n    // given\n    PaymentDto paymentDto = createTestPaymentDto();\n\n    com.myhome.model.SchedulePaymentResponse expectedResponse =\n        new com.myhome.model.SchedulePaymentResponse()\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    given(paymentService.getPaymentDetails(TEST_ID))\n        .willReturn(Optional.of(paymentDto));\n    given(paymentApiMapper.paymentToSchedulePaymentResponse(paymentDto))\n        .willReturn(expectedResponse);\n\n    // when\n    ResponseEntity<com.myhome.model.SchedulePaymentResponse> responseEntity =\n        paymentController.listPaymentDetails(TEST_ID);\n\n    // then\n    assertEquals(HttpStatus.OK, responseEntity.getStatusCode());\n    assertEquals(expectedResponse, responseEntity.getBody());\n    verify(paymentService).getPaymentDetails(TEST_ID);\n    verify(paymentApiMapper).paymentToSchedulePaymentResponse(paymentDto);\n  }\n","description":"\nThis test ensures that the getPaymentDetails method of the PaymentController will return a valid response. In this case, the expected result is to have a HttpStatus code of OK and the actual response body should match what the paymentApiMapper returns from the given paymentService.getPaymentDetails(TEST_ID) method. The verify() methods are used to ensure that the correct methods were called on the paymentService and paymentApiMapper objects, respectively."},"name":"shouldGetPaymentDetailsSuccess","code":"@Test\n  void shouldGetPaymentDetailsSuccess() {\n    // given\n    PaymentDto paymentDto = createTestPaymentDto();\n\n    com.myhome.model.SchedulePaymentResponse expectedResponse =\n        new com.myhome.model.SchedulePaymentResponse()\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    given(paymentService.getPaymentDetails(TEST_ID))\n        .willReturn(Optional.of(paymentDto));\n    given(paymentApiMapper.paymentToSchedulePaymentResponse(paymentDto))\n        .willReturn(expectedResponse);\n\n    // when\n    ResponseEntity<com.myhome.model.SchedulePaymentResponse> responseEntity =\n        paymentController.listPaymentDetails(TEST_ID);\n\n    // then\n    assertEquals(HttpStatus.OK, responseEntity.getStatusCode());\n    assertEquals(expectedResponse, responseEntity.getBody());\n    verify(paymentService).getPaymentDetails(TEST_ID);\n    verify(paymentApiMapper).paymentToSchedulePaymentResponse(paymentDto);\n  }","location":{"start":380,"insert":380,"offset":" ","indent":2,"comment":null},"item_type":"method","length":30},{"id":"ee757e2f-1298-1192-334b-d4d413ddd3e1","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"tests the `listPaymentDetails` method of a payment controller by providing a test ID and verifying that the method returns a `HttpStatus.NOT_FOUND` status code and no payment details when no payment details are available for the given test ID.","params":[],"usage":{"language":"java","code":"@Test\n  void shouldListNoPaymentDetailsSuccess() {\n    //given\n    given(paymentService.getPaymentDetails(TEST_ID))\n        .willReturn(Optional.empty());\n\n    //when\n    ResponseEntity<com.myhome.model.SchedulePaymentResponse> responseEntity =\n        paymentController.listPaymentDetails(TEST_ID);\n\n    //then\n    assertEquals(HttpStatus.NOT_FOUND, responseEntity.getStatusCode());\n    assertNull(responseEntity.getBody());\n    verify(paymentService).getPaymentDetails(TEST_ID);\n    verifyNoInteractions(paymentApiMapper);\n  }\n}\n","description":"\nIn this example, the method shouldListNoPaymentDetailsSuccess is a unit test for the controller method listPaymentDetails that retrieves payment details by id. The method creates a mock PaymentService and PaymentApiMapper instances using the given() method of Mockito, sets up an expectation that when getPaymentDetails(TEST_ID) method of PaymentService is called, it should return an empty optional.\nThe test then asserts that the response status code is NOT_FOUND and there is no body in the response, this can be done using the getStatusCode() and getBody() methods of ResponseEntity class respectively. The test also verifies that the getPaymentDetails(TEST_ID) method of PaymentService was called using verify(paymentService).getPaymentDetails(TEST_ID). Finally, the test verifies that no interactions were made with the paymentApiMapper instance using verifyNoInteractions(paymentApiMapper) method."},"name":"shouldListNoPaymentDetailsSuccess","code":"@Test\n  void shouldListNoPaymentDetailsSuccess() {\n    //given\n    given(paymentService.getPaymentDetails(TEST_ID))\n        .willReturn(Optional.empty());\n\n    //when\n    ResponseEntity<com.myhome.model.SchedulePaymentResponse> responseEntity =\n        paymentController.listPaymentDetails(TEST_ID);\n\n    //then\n    assertEquals(HttpStatus.NOT_FOUND, responseEntity.getStatusCode());\n    assertNull(responseEntity.getBody());\n    verify(paymentService).getPaymentDetails(TEST_ID);\n    verifyNoInteractions(paymentApiMapper);\n  }","location":{"start":411,"insert":411,"offset":" ","indent":2,"comment":null},"item_type":"method","length":16},{"id":"fc4817f6-bcd3-61b6-d34c-23d64d93245c","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"tests whether the `listAllMemberPayments` method returns a response with a status code of `HttpStatus.NOT_FOUND` and an empty list when no member payments are found for the given member ID.","params":[],"usage":{"language":"java","code":"@Test\n  void shouldGetNoMemberPaymentsSuccess() {\n    //given\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.empty());\n\n    //when\n    ResponseEntity<ListMemberPaymentsResponse> responseEntity =\n        paymentController.listAllMemberPayments(TEST_MEMBER_ID);\n\n    //then\n    assertEquals(HttpStatus.NOT_FOUND, responseEntity.getStatusCode());\n    assertNull(responseEntity.getBody());\n    verifyNoInteractions(paymentApiMapper);\n  }\n","description":"\nIn this example, we are using JUnit5 to write a unit test for the `shouldGetNoMemberPaymentsSuccess` method in the PaymentController class. We first set up some mock behavior for the `paymentService`, by giving it an empty Optional when it is called with TEST_MEMBER_ID as input. Then, we call the `listAllMemberPayments` method and assert that it returns a ResponseEntity with status code NOT_FOUND and body null. Finally, we verify that no interactions were made with paymentApiMapper, which means that no API calls were actually made to the Payment Service.\n\nThis test is testing the edge case where no payments have been scheduled for the given member ID, and we want to make sure that it returns an HTTP 404 NOT FOUND response."},"name":"shouldGetNoMemberPaymentsSuccess","code":"@Test\n  void shouldGetNoMemberPaymentsSuccess() {\n    //given\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.empty());\n\n    //when\n    ResponseEntity<ListMemberPaymentsResponse> responseEntity =\n        paymentController.listAllMemberPayments(TEST_MEMBER_ID);\n\n    //then\n    assertEquals(HttpStatus.NOT_FOUND, responseEntity.getStatusCode());\n    assertNull(responseEntity.getBody());\n    verifyNoInteractions(paymentApiMapper);\n  }","location":{"start":428,"insert":428,"offset":" ","indent":2,"comment":null},"item_type":"method","length":15},{"id":"af864d0b-61bc-d08d-3d47-08a737248cb5","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"tests the `listAllMemberPayments` method of a payment controller by providing a member ID and verifying that the response contains the expected payments in the correct format.","params":[],"usage":{"language":"java","code":"@Test\n  void shouldGetMemberPaymentsSuccess() {\n    // given\n    PaymentDto paymentDto = createTestPaymentDto();\n\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n\n    HouseMember member = new HouseMember(TEST_MEMBER_ID, null, TEST_MEMBER_NAME, null);\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.of(member));\n\n    Set<Payment> payments = new HashSet<>();\n    Payment mockPayment = getMockPayment();\n    payments.add(mockPayment);\n\n    given(paymentService.getPaymentsByMember(TEST_MEMBER_ID))\n        .willReturn(payments);\n\n    Set<MemberPayment> paymentResponses = new HashSet<>();\n    paymentResponses.add(\n        new MemberPayment()\n            .memberId(TEST_MEMBER_ID)\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE));\n\n    ListMemberPaymentsResponse expectedResponse =\n        new ListMemberPaymentsResponse().payments(paymentResponses);\n\n    given(paymentApiMapper.memberPaymentSetToRestApiResponseMemberPaymentSet(payments))\n        .willReturn(paymentResponses);\n\n    // when\n    ResponseEntity<ListMemberPaymentsResponse> responseEntity =\n        paymentController.listAllMemberPayments(TEST_MEMBER_ID);\n\n    // then\n    assertEquals(HttpStatus.OK, responseEntity.getStatusCode());\n    assertEquals(responseEntity.getBody(), expectedResponse);\n    verify(paymentService).getPaymentsByMember(TEST_MEMBER_ID);\n    verify(paymentApiMapper)\n        .memberPaymentSetToRestApiResponseMemberPaymentSet(payments);\n  }\n","description":"\nThe above example is a test method that should be used to ensure the correct functionality of the `listAllMemberPayments` method. The tests are checking that the `listAllMemberPayments` method returns a list of payments for a given member ID, and that the mapper converts the payment set returned by the payment service into a response object for the controller.\nThe test first creates some mock payments and sets up the payment service to return those payments when queried for a given member's payments. It then calls `listAllMemberPayments` with that same member ID, which should return the list of payments that were returned by the service. Finally, it verifies that the response from the controller matches what was expected.\nIt's important to note that this is a very basic example and in reality you would likely be testing for other things such as invalid or malformed requests, and also checking for the correctness of the responses for different cases (i.e. not found, unauthorized) but those are details for another exercise."},"name":"shouldGetMemberPaymentsSuccess","code":"@Test\n  void shouldGetMemberPaymentsSuccess() {\n    // given\n    PaymentDto paymentDto = createTestPaymentDto();\n\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n\n    HouseMember member = new HouseMember(TEST_MEMBER_ID, null, TEST_MEMBER_NAME, null);\n    given(paymentService.getHouseMember(TEST_MEMBER_ID))\n        .willReturn(Optional.of(member));\n\n    Set<Payment> payments = new HashSet<>();\n    Payment mockPayment = getMockPayment();\n    payments.add(mockPayment);\n\n    given(paymentService.getPaymentsByMember(TEST_MEMBER_ID))\n        .willReturn(payments);\n\n    Set<MemberPayment> paymentResponses = new HashSet<>();\n    paymentResponses.add(\n        new MemberPayment()\n            .memberId(TEST_MEMBER_ID)\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE));\n\n    ListMemberPaymentsResponse expectedResponse =\n        new ListMemberPaymentsResponse().payments(paymentResponses);\n\n    given(paymentApiMapper.memberPaymentSetToRestApiResponseMemberPaymentSet(payments))\n        .willReturn(paymentResponses);\n\n    // when\n    ResponseEntity<ListMemberPaymentsResponse> responseEntity =\n        paymentController.listAllMemberPayments(TEST_MEMBER_ID);\n\n    // then\n    assertEquals(HttpStatus.OK, responseEntity.getStatusCode());\n    assertEquals(responseEntity.getBody(), expectedResponse);\n    verify(paymentService).getPaymentsByMember(TEST_MEMBER_ID);\n    verify(paymentApiMapper).memberPaymentSetToRestApiResponseMemberPaymentSet(payments);\n  }","location":{"start":444,"insert":444,"offset":" ","indent":2,"comment":null},"item_type":"method","length":43},{"id":"e7e6ea74-36a6-58b6-1041-f620795cbbd7","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"tests the listAllAdminScheduledPayments endpoint, where it retrieves all scheduled payments for a given admin and community, and returns them in a paginated response.","params":[],"usage":{"language":"java","code":"@Test\n  void shouldGetAdminPaymentsSuccess() {\n    // given\n    com.myhome.model.SchedulePaymentRequest request =\n        new com.myhome.model.SchedulePaymentRequest()\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    PaymentDto paymentDto = createTestPaymentDto();\n\n    given(paymentService.schedulePayment(paymentDto)).willReturn(paymentDto);\n\n    List<Payment> payments = new ArrayList<>();\n    Payment mockPayment = getMockPayment();\n    payments.add(mockPayment);\n\n    Set<String> adminIds = new HashSet<>();\n    adminIds.add(TEST_ADMIN_ID);\n\n    Set<User> admins = new HashSet<>();\n\n    Community community = getMockCommunity(admins);\n\n    CommunityDto communityDto = createTestCommunityDto();\n\n    given(communityService.createCommunity(communityDto)).willReturn(community);\n    given(communityService.getCommunityDetailsByIdWithAdmins(TEST_ID))\n        .willReturn(Optional.of(community));\n    given(paymentService.getPaymentsByAdmin(TEST_ADMIN_ID, TEST_PAGEABLE))\n        .willReturn(new PageImpl<>(payments));\n    given(communityService.addAdminsToCommunity(TEST_ID, adminIds))\n        .willReturn(Optional.of(community));\n\n    Set<AdminPayment> responsePayments = new HashSet<>();\n    responsePayments.add(\n        new AdminPayment()\n            .adminId(TEST_ADMIN_ID)\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE));\n\n    ListAdminPaymentsResponse expectedResponse =\n        new ListAdminPaymentsResponse()\n            .payments(responsePayments)\n            .pageInfo(PageInfo.of(TEST_PAGEABLE, new PageImpl<>(payments)));\n\n    given(paymentApiMapper.adminPaymentSetToRestApiResponseAdminPaymentSet(new HashSet<>(payments)))\n        .willReturn(responsePayments);\n\n    //when\n    ResponseEntity<ListAdminPaymentsResponse> responseEntity =\n        paymentController.listAllAdminScheduledPayments(TEST_ID, TEST_ADMIN_ID, TEST_PAGEABLE);\n\n    //then\n    assertEquals(HttpStatus.OK, responseEntity.getStatusCode());\n    assertEquals(expectedResponse, responseEntity.getBody());\n    verify(communityService).getCommunityDetailsByIdWithAdmins(TEST_ID);\n    verify(paymentService).getPaymentsByAdmin(TEST_ADMIN_ID, TEST_PAGEABLE);\n    verify(paymentApiMapper).adminPaymentSetToRestApiResponseAdminPaymentSet(new HashSet<>(payments));\n  }\n","description":"\nIn the example above, we first create a SchedulePaymentRequest object. We then schedule the payment using the paymentService.schedulePayment method by passing in a PaymentDto object. After that, we add the adminId to the community service.\nWe next get the community details by calling communityService.getCommunityDetailsByIdWithAdmins and verify the response is an Optional with a Community object. We then pass the TEST_ID to paymentService.getPaymentsByAdmin and assert it returns a PageImpl<Payment>. Finally, we add the adminId to the community using communityService.addAdminsToCommunity.\nAfter that, we verify the response is an Optional with a Community object. We then pass the TEST_ID to paymentService.getPaymentsByAdmin and assert it returns a PageImpl<Payment>. Finally, we add the adminId to the community using communityService.addAdminsToCommunity.\nWe next create a ListAdminPaymentsResponse object with the response payments from the paymentApiMapper.adminPaymentSetToRestApiResponseAdminPaymentSet method. We then verify the response is an Optional with a Community object. Finally, we assert that the response contains the expectedResponse."},"name":"shouldGetAdminPaymentsSuccess","code":"@Test\n  void shouldGetAdminPaymentsSuccess() {\n    // given\n    com.myhome.model.SchedulePaymentRequest request =\n        new com.myhome.model.SchedulePaymentRequest()\n            .type(TEST_TYPE)\n            .description(TEST_DESCRIPTION)\n            .recurring(TEST_RECURRING)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n            .adminId(TEST_ADMIN_ID)\n            .memberId(TEST_MEMBER_ID);\n    PaymentDto paymentDto = createTestPaymentDto();\n\n    given(paymentService.schedulePayment(paymentDto))\n        .willReturn(paymentDto);\n\n    List<Payment> payments = new ArrayList<>();\n    Payment mockPayment = getMockPayment();\n    payments.add(mockPayment);\n\n    Set<String> adminIds = new HashSet<>();\n    adminIds.add(TEST_ADMIN_ID);\n\n    Set<User> admins = new HashSet<>();\n\n    Community community = getMockCommunity(admins);\n\n    CommunityDto communityDto = createTestCommunityDto();\n\n    given(communityService.createCommunity(communityDto))\n        .willReturn(community);\n    given(communityService.getCommunityDetailsByIdWithAdmins(TEST_ID))\n        .willReturn(Optional.of(community));\n    given(paymentService.getPaymentsByAdmin(TEST_ADMIN_ID, TEST_PAGEABLE))\n        .willReturn(new PageImpl<>(payments));\n    given(communityService.addAdminsToCommunity(TEST_ID, adminIds))\n        .willReturn(Optional.of(community));\n\n    Set<AdminPayment> responsePayments = new HashSet<>();\n    responsePayments.add(\n        new AdminPayment().adminId(TEST_ADMIN_ID)\n            .paymentId(TEST_ID)\n            .charge(TEST_CHARGE)\n            .dueDate(TEST_DUE_DATE)\n    );\n\n    ListAdminPaymentsResponse expectedResponse =\n        new ListAdminPaymentsResponse()\n            .payments(responsePayments)\n            .pageInfo(PageInfo.of(TEST_PAGEABLE, new PageImpl<>(payments)));\n\n    given(paymentApiMapper.adminPaymentSetToRestApiResponseAdminPaymentSet(new HashSet<>(payments)))\n        .willReturn(responsePayments);\n\n    //when\n    ResponseEntity<ListAdminPaymentsResponse> responseEntity =\n        paymentController.listAllAdminScheduledPayments(TEST_ID, TEST_ADMIN_ID,\n            TEST_PAGEABLE);\n\n    //then\n    assertEquals(HttpStatus.OK, responseEntity.getStatusCode());\n    assertEquals(expectedResponse, responseEntity.getBody());\n    verify(communityService).getCommunityDetailsByIdWithAdmins(TEST_ID);\n    verify(paymentService).getPaymentsByAdmin(TEST_ADMIN_ID, TEST_PAGEABLE);\n    verify(paymentApiMapper).adminPaymentSetToRestApiResponseAdminPaymentSet(\n        new HashSet<>(payments));\n  }","location":{"start":488,"insert":488,"offset":" ","indent":2,"comment":null},"item_type":"method","length":68},{"id":"b9f4a107-e65e-40aa-0f42-9aa26b04b0fe","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"verifies that when an admin is not in a community, the listAllAdminScheduledPayments method returns a `HttpStatus.NOT_FOUND` response and no admins are returned in the body of the response.","params":[],"usage":{"language":"java","code":"@Test\n  void shouldReturnNotFoundWhenAdminIsNotInCommunity() {\n    //given\n    final String notAdminFromCommunity = \"2\";\n    Community community = getMockCommunity(new HashSet<>());\n    given(communityService.getCommunityDetailsByIdWithAdmins(TEST_ID))\n        .willReturn(Optional.of(community));\n\n    //when\n    ResponseEntity<ListAdminPaymentsResponse> responseEntity =\n        paymentController.listAllAdminScheduledPayments(TEST_ID, notAdminFromCommunity,\n            TEST_PAGEABLE);\n\n    //then\n    assertEquals(HttpStatus.NOT_FOUND, responseEntity.getStatusCode());\n    assertNull(responseEntity.getBody());\n    verify(communityService).getCommunityDetailsByIdWithAdmins(TEST_ID);\n    verifyNoInteractions(paymentService);\n  }\n","description":"\nThis example shows how to test that the method shouldReturnNotFoundWhenAdminIsNotInCommunity throws a RuntimeException when an admin is not found in the community. This method uses mockito to create a mocked Community and to verify the interactions with the communityService and paymentService. It also asserts that the status code of the response entity is HttpStatus.NOT_FOUND and that the body of the response entity is null."},"name":"shouldReturnNotFoundWhenAdminIsNotInCommunity","code":"@Test\n  void shouldReturnNotFoundWhenAdminIsNotInCommunity() {\n    //given\n    final String notAdminFromCommunity = \"2\";\n    Community community = getMockCommunity(new HashSet<>());\n    given(communityService.getCommunityDetailsByIdWithAdmins(TEST_ID))\n        .willReturn(Optional.of(community));\n\n    //when\n    ResponseEntity<ListAdminPaymentsResponse> responseEntity =\n        paymentController.listAllAdminScheduledPayments(TEST_ID, notAdminFromCommunity,\n            TEST_PAGEABLE);\n\n    //then\n    assertEquals(HttpStatus.NOT_FOUND, responseEntity.getStatusCode());\n    assertNull(responseEntity.getBody());\n    verify(communityService).getCommunityDetailsByIdWithAdmins(TEST_ID);\n    verifyNoInteractions(paymentService);\n  }","location":{"start":557,"insert":557,"offset":" ","indent":2,"comment":null},"item_type":"method","length":19},{"id":"c599d403-2492-cfba-5943-a55062756b67","ancestors":["1f1221b9-649b-bfbc-2d44-6780dbc49388"],"type":"function","description":"tests whether a `RuntimeException` is thrown when the community with the given ID does not exist.","params":[],"usage":{"language":"java","code":"@Test\n  void shouldThrowExceptionWhenCommunityNotExists() {\n    //given\n    String expectedExceptionMessage = \"Community with given id not exists: \" + TEST_ID;\n\n    given(communityService.getCommunityDetailsByIdWithAdmins(TEST_ID))\n        .willReturn(Optional.empty());\n\n    //when\n    final RuntimeException runtimeException = assertThrows(\n        RuntimeException.class,\n        () -> paymentController.listAllAdminScheduledPayments(TEST_ID, TEST_ADMIN_ID,\n            TEST_PAGEABLE)\n    );\n\n    //then\n    assertEquals(expectedExceptionMessage, runtimeException.getMessage());\n    verify(communityService).getCommunityDetailsByIdWithAdmins(TEST_ID);\n    verifyNoInteractions(paymentService);\n    verifyNoInteractions(paymentApiMapper);\n  }\n","description":"\nThe example method shouldThrowExceptionWhenCommunityNotExists is a test method that tests the functionality of the `shouldThrowExceptionWhenCommunityNotExists` method in the PaymentController.java class. It uses the `assertThrows()` method from JUnit to check if an exception is thrown when calling the `listAllAdminScheduledPayments` method with a community ID that does not exist, and verifies that the expected exception message matches the actual exception message.\n\nThis test should be run on its own by right-clicking on the method name in the editor and selecting \"Run 'shouldThrowExceptionWhenCommunityNotExists'\" or by using the shortcut key Ctrl + Shift + F10 (Windows/Linux) or Cmd + Shift + F10 (Mac). The test should pass.\n\nIn general, the purpose of a unit test is to ensure that your code works as expected and does not have any errors. In this case, the purpose of the `shouldThrowExceptionWhenCommunityNotExists` test method is to ensure that when a community ID is passed in but the community does not exist, an exception is thrown."},"name":"shouldThrowExceptionWhenCommunityNotExists","code":"@Test\n  void shouldThrowExceptionWhenCommunityNotExists() {\n    //given\n    String expectedExceptionMessage = \"Community with given id not exists: \" + TEST_ID;\n\n    given(communityService.getCommunityDetailsByIdWithAdmins(TEST_ID))\n        .willReturn(Optional.empty());\n\n    //when\n    final RuntimeException runtimeException = assertThrows(\n        RuntimeException.class,\n        () -> paymentController.listAllAdminScheduledPayments(TEST_ID, TEST_ADMIN_ID,\n            TEST_PAGEABLE)\n    );\n\n    //then\n    assertEquals(expectedExceptionMessage, runtimeException.getMessage());\n    verify(communityService).getCommunityDetailsByIdWithAdmins(TEST_ID);\n    verifyNoInteractions(paymentService);\n    verifyNoInteractions(paymentApiMapper);\n  }","location":{"start":577,"insert":577,"offset":" ","indent":2,"comment":null},"item_type":"method","length":21}]}}}